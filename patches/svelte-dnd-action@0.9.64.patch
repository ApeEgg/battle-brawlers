diff --git a/dist/index.d.ts b/dist/index.d.ts
index ba6b9f7108677b267552e88b33f1d6639cf2c47a..9ad148e866c827e598f3d93ac70458889c5e0774 100644
--- a/dist/index.d.ts
+++ b/dist/index.d.ts
@@ -1,39 +1,14 @@
-import type {ActionReturn} from "svelte/action";
-
 /**
  * A custom action to turn any container to a dnd zone and all of its direct children to draggables
  * Supports mouse, touch and keyboard interactions.
  * Dispatches two events that the container is expected to react to by modifying its list of items,
  * which will then feed back in to this action via the update function
  */
-export declare function dndzone<T extends Item>(node: HTMLElement, options: Options<T>): ActionReturn<Options<T>, DndZoneAttributes<T>>;
-
-export declare function dndzone<T extends Item>(
-    node: HTMLElement,
-    options: Options<T>
-): {
-    update: (newOptions: Options<T>) => void;
-    destroy: () => void;
-};
-
-/**
- * A wrapper action to make it easy to work with drag handles.
- * When using this you must also use the 'dragHandle' action on an element inside each item within the zone.
- */
-export declare function dragHandleZone<T extends Item>(node: HTMLElement, options: Options<T>): ActionReturn<Options<T>, DndZoneAttributes<T>>;
-export declare function dragHandleZone<T extends Item>(
+export declare function dndzone(
     node: HTMLElement,
-    options: Options<T>
+    options: Options
 ): {
-    update: (newOptions: Options<T>) => void;
-    destroy: () => void;
-};
-
-/**
- * This should be used to mark drag handles inside items that belong to a 'dragHandleZone'
- */
-export declare function dragHandle(node: HTMLElement): {
-    update: () => void;
+    update: (newOptions: Options) => void;
     destroy: () => void;
 };
 
@@ -44,33 +19,21 @@ export type TransformDraggedElementFunction = (
 ) => void;
 
 export declare type Item = Record<string, any>;
-export interface Options<T extends Item = Item> {
-    items: T[]; // the list of items that was used to generate the children of the given node
+export interface Options {
+    items: Item[]; // the list of items that was used to generate the children of the given node
     type?: string; // the type of the dnd zone. children dragged from here can only be dropped in other zones of the same type, defaults to a base type
     flipDurationMs?: number; // if the list animated using flip (recommended), specifies the flip duration such that everything syncs with it without conflict
+    constrainAxisX?: boolean; // Constrain dragging by X axis. Drag will be allowed only by Y axis.
+    constrainAxisY?: boolean; // Constrain dragging by Y axis. Drag will be allowed only by X axis.
     dragDisabled?: boolean;
     morphDisabled?: boolean;
     dropFromOthersDisabled?: boolean;
     zoneTabIndex?: number; // set the tabindex of the list container when not dragging
-    zoneItemTabIndex?: number; // set the tabindex of the list container items when not dragging
     dropTargetClasses?: string[];
     dropTargetStyle?: Record<string, string>;
     transformDraggedElement?: TransformDraggedElementFunction;
     autoAriaDisabled?: boolean;
     centreDraggedOnCursor?: boolean;
-    dropAnimationDisabled?: boolean;
-    /**
-     * Improve touch UX: true => default 80 ms delay, number => custom delay in ms.
-     * false/undefined => drag starts instantly (legacy behaviour)
-     */
-    delayTouchStart?: boolean | number;
-}
-
-export interface DndZoneAttributes<T> {
-    "on:consider"?: (e: CustomEvent<DndEvent<T>>) => void;
-    "on:finalize"?: (e: CustomEvent<DndEvent<T>>) => void;
-    onconsider?: (e: CustomEvent<DndEvent<T>>) => void;
-    onfinalize?: (e: CustomEvent<DndEvent<T>>) => void;
 }
 
 /**
@@ -117,15 +80,8 @@ export type DndEvent<T = Item> = {
 export declare const SHADOW_ITEM_MARKER_PROPERTY_NAME: "isDndShadowItem";
 export declare const SHADOW_PLACEHOLDER_ITEM_ID: "id:dnd-shadow-placeholder-0000";
 export declare const DRAGGED_ELEMENT_ID: "dnd-action-dragged-el";
-export declare const SHADOW_ELEMENT_HINT_ATTRIBUTE_NAME = "data-is-dnd-shadow-item-hint";
 
 /**
  * Allows the user to show/hide console debug output
  */
 export declare function setDebugMode(isDebug: boolean): void;
-
-export enum FEATURE_FLAG_NAMES {
-    // Default value: false, This flag exists as a workaround for issue 454 (basically a browser bug) - seems like these rect values take time to update when in grid layout. Setting it to true can cause strange behaviour in the REPL for non-grid zones, see issue 470
-    USE_COMPUTED_STYLE_INSTEAD_OF_BOUNDING_RECT = "FEATURE_FLAG_NAMES.USE_COMPUTED_STYLE_INSTEAD_OF_BOUNDING_RECT"
-}
-export declare function setFeatureFlag(flagName: FEATURE_FLAG_NAMES, flagValue: boolean);
diff --git a/dist/index.js b/dist/index.js
index f13c0243ee6115d7945a27261b6a09e814c60a91..f63b0d21cbd4d1fdd095f025f6aaae0ba6659807 100644
--- a/dist/index.js
+++ b/dist/index.js
@@ -294,8 +294,7 @@
     KEYBOARD: "keyboard"
   };
   var SHADOW_ITEM_MARKER_PROPERTY_NAME = "isDndShadowItem";
-  var SHADOW_ELEMENT_ATTRIBUTE_NAME = "data-is-dnd-shadow-item-internal";
-  var SHADOW_ELEMENT_HINT_ATTRIBUTE_NAME = "data-is-dnd-shadow-item-hint";
+  var SHADOW_ELEMENT_ATTRIBUTE_NAME = "data-is-dnd-shadow-item";
   var SHADOW_PLACEHOLDER_ITEM_ID = "id:dnd-shadow-placeholder-0000";
   var DRAGGED_ELEMENT_ID = "dnd-action-dragged-el";
   var ITEM_ID_KEY = "id";
@@ -333,7 +332,7 @@
 
   /**
    * Allows the user to show/hide console debug output
-   * * @param {boolean} isDebug
+   * * @param {Boolean} isDebug
    */
   function setDebugMode(isDebug) {
     if (isDebug) {
@@ -356,13 +355,11 @@
   /**
    * Gets the bounding rect but removes transforms (ex: flip animation)
    * @param {HTMLElement} el
-   * @param {boolean} [onlyVisible] - use the visible rect defaults to true
    * @return {{top: number, left: number, bottom: number, right: number}}
    */
   function getBoundingRectNoTransforms(el) {
-    var onlyVisible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
     var ta;
-    var rect = onlyVisible ? getVisibleRectRecursive(el) : el.getBoundingClientRect();
+    var rect = el.getBoundingClientRect();
     var style = getComputedStyle(el);
     var tx = style.transform;
     if (tx) {
@@ -503,58 +500,30 @@
 
   /**
    * @param {HTMLElement} el - the element to check
-   * @returns {boolean} - true if the element in its entirety is off-screen including the scrollable area (the normal dom events look at the mouse rather than the element)
+   * @returns {boolean} - true if the element in its entirety is off screen including the scrollable area (the normal dom events look at the mouse rather than the element)
    */
   function isElementOffDocument(el) {
     var rect = getAbsoluteRect(el);
     return rect.right < 0 || rect.left > document.documentElement.scrollWidth || rect.bottom < 0 || rect.top > document.documentElement.scrollHeight;
   }
-  function getVisibleRectRecursive(element) {
-    var rect = element.getBoundingClientRect();
-    var visibleRect = {
-      top: rect.top,
-      bottom: rect.bottom,
-      left: rect.left,
-      right: rect.right
-    };
 
-    // Traverse up the DOM hierarchy, checking for scrollable ancestors
-    var parent = element.parentElement;
-    while (parent && parent !== document.body) {
-      var parentRect = parent.getBoundingClientRect();
-
-      // Check if the parent has a scrollable overflow
-      var overflowY = window.getComputedStyle(parent).overflowY;
-      var overflowX = window.getComputedStyle(parent).overflowX;
-      var isScrollableY = overflowY === "scroll" || overflowY === "auto";
-      var isScrollableX = overflowX === "scroll" || overflowX === "auto";
-
-      // Constrain the visible area to the parent's visible area
-      if (isScrollableY) {
-        visibleRect.top = Math.max(visibleRect.top, parentRect.top);
-        visibleRect.bottom = Math.min(visibleRect.bottom, parentRect.bottom);
-      }
-      if (isScrollableX) {
-        visibleRect.left = Math.max(visibleRect.left, parentRect.left);
-        visibleRect.right = Math.min(visibleRect.right, parentRect.right);
-      }
-      parent = parent.parentElement;
+  /**
+   * If the point is inside the element returns its distances from the sides, otherwise returns null
+   * @param {Point} point
+   * @param {HTMLElement} el
+   * @return {null|{top: number, left: number, bottom: number, right: number}}
+   */
+  function calcInnerDistancesBetweenPointAndSidesOfElement(point, el) {
+    var rect = getAbsoluteRect(el);
+    if (!isPointInsideRect(point, rect)) {
+      return null;
     }
-
-    // Finally, constrain the visible rect to the viewport
-    visibleRect.top = Math.max(visibleRect.top, 0);
-    visibleRect.bottom = Math.min(visibleRect.bottom, window.innerHeight);
-    visibleRect.left = Math.max(visibleRect.left, 0);
-    visibleRect.right = Math.min(visibleRect.right, window.innerWidth);
-
-    // Return the visible rectangle, ensuring that all values are valid
     return {
-      top: visibleRect.top,
-      bottom: visibleRect.bottom,
-      left: visibleRect.left,
-      right: visibleRect.right,
-      width: Math.max(0, visibleRect.right - visibleRect.left),
-      height: Math.max(0, visibleRect.bottom - visibleRect.top)
+      top: point.y - rect.top,
+      bottom: rect.bottom - point.y,
+      left: point.x - rect.left,
+      // TODO - figure out what is so special about right (why the rect is too big)
+      right: Math.min(rect.right, document.documentElement.clientWidth) - point.x
     };
   }
 
@@ -571,6 +540,17 @@
   }
   resetIndexesCache();
 
+  /**
+   * Resets the cache that allows for smarter "would be index" resolution for a specific dropzone, should be called after the zone was scrolled
+   * @param {HTMLElement} dz
+   */
+  function resetIndexesCacheForDz(dz) {
+    printDebug(function () {
+      return "resetting indexes cache for dz";
+    });
+    dzToShadowIndexToRect["delete"](dz);
+  }
+
   /**
    * Caches the coordinates of the shadow element when it's in a certain index in a certain dropzone.
    * Helpful in order to determine "would be index" more effectively
@@ -647,35 +627,105 @@
         indexOfMin = _i;
       }
     }
+    return {
+      index: indexOfMin,
+      isProximityBased: true
+    };
+  }
 
-    // -------- Phantom slot check --------
-    // Regardless of layout (simple vertical list, flex-wrap, grid, floats …) the
-    // visually closest drop target can be *after* the current last **real** child.
-    // In simple layouts the would be index from the existing children would always be the last index
-    // but in more complex layouts (flex-wrap, grid, floats …) it can be any index.
-    // The problem is we can't predict where an additional element would be rendered in the general case,
-    // We therefore create a temporary, invisible clone of that last element, let
-    // the browser position it, measure the distance, and remove it immediately
-    // (same task → no paint).  This leaves `children` back in its original state
-    // before we exit the function, so existing index-caching logic and shadow-
-    // element bookkeeping continue to work unchanged.
-    if (children.length > 0) {
-      var originalLen = children.length; // before we append the phantom
-      var template = children[originalLen - 1];
-      var phantom = template.cloneNode(false); // shallow clone is enough for size
-      phantom.style.visibility = "hidden";
-      phantom.style.pointerEvents = "none";
-      collectionBelowEl.appendChild(phantom);
-      var phantomDistance = calcDistanceBetweenCenters(floatingAboveEl, phantom);
-      if (phantomDistance < minDistanceSoFar) {
-        indexOfMin = originalLen; // index of phantom slot in original list
+  var SCROLL_ZONE_PX = 25;
+  function makeScroller() {
+    var scrollingInfo;
+    function resetScrolling() {
+      scrollingInfo = {
+        directionObj: undefined,
+        stepPx: 0
+      };
+    }
+    resetScrolling();
+    // directionObj {x: 0|1|-1, y:0|1|-1} - 1 means down in y and right in x
+    function scrollContainer(containerEl) {
+      var _scrollingInfo = scrollingInfo,
+        directionObj = _scrollingInfo.directionObj,
+        stepPx = _scrollingInfo.stepPx;
+      if (directionObj) {
+        containerEl.scrollBy(directionObj.x * stepPx, directionObj.y * stepPx);
+        window.requestAnimationFrame(function () {
+          return scrollContainer(containerEl);
+        });
       }
+    }
+    function calcScrollStepPx(distancePx) {
+      return SCROLL_ZONE_PX - distancePx;
+    }
 
-      collectionBelowEl.removeChild(phantom);
+    /**
+     * If the pointer is next to the sides of the element to scroll, will trigger scrolling
+     * Can be called repeatedly with updated pointer and elementToScroll values without issues
+     * @return {boolean} - true if scrolling was needed
+     */
+    function scrollIfNeeded(pointer, elementToScroll) {
+      if (!elementToScroll) {
+        return false;
+      }
+      var distances = calcInnerDistancesBetweenPointAndSidesOfElement(pointer, elementToScroll);
+      if (distances === null) {
+        resetScrolling();
+        return false;
+      }
+      var isAlreadyScrolling = !!scrollingInfo.directionObj;
+      var scrollingVertically = false,
+        scrollingHorizontally = false;
+      // vertical
+      if (elementToScroll.scrollHeight > elementToScroll.clientHeight) {
+        if (distances.bottom < SCROLL_ZONE_PX) {
+          scrollingVertically = true;
+          scrollingInfo.directionObj = {
+            x: 0,
+            y: 1
+          };
+          scrollingInfo.stepPx = calcScrollStepPx(distances.bottom);
+        } else if (distances.top < SCROLL_ZONE_PX) {
+          scrollingVertically = true;
+          scrollingInfo.directionObj = {
+            x: 0,
+            y: -1
+          };
+          scrollingInfo.stepPx = calcScrollStepPx(distances.top);
+        }
+        if (!isAlreadyScrolling && scrollingVertically) {
+          scrollContainer(elementToScroll);
+          return true;
+        }
+      }
+      // horizontal
+      if (elementToScroll.scrollWidth > elementToScroll.clientWidth) {
+        if (distances.right < SCROLL_ZONE_PX) {
+          scrollingHorizontally = true;
+          scrollingInfo.directionObj = {
+            x: 1,
+            y: 0
+          };
+          scrollingInfo.stepPx = calcScrollStepPx(distances.right);
+        } else if (distances.left < SCROLL_ZONE_PX) {
+          scrollingHorizontally = true;
+          scrollingInfo.directionObj = {
+            x: -1,
+            y: 0
+          };
+          scrollingInfo.stepPx = calcScrollStepPx(distances.left);
+        }
+        if (!isAlreadyScrolling && scrollingHorizontally) {
+          scrollContainer(elementToScroll);
+          return true;
+        }
+      }
+      resetScrolling();
+      return false;
     }
     return {
-      index: indexOfMin,
-      isProximityBased: true
+      scrollIfNeeded: scrollIfNeeded,
+      resetScrolling: resetScrolling
     };
   }
 
@@ -742,20 +792,21 @@
     return true;
   }
 
-  var INTERVAL_MS = 200;
+  var INTERVAL_MS$1 = 200;
   var TOLERANCE_PX = 10;
-  var next;
+  var _makeScroller$1 = makeScroller(),
+    scrollIfNeeded$1 = _makeScroller$1.scrollIfNeeded,
+    resetScrolling$1 = _makeScroller$1.resetScrolling;
+  var next$1;
 
   /**
    * Tracks the dragged elements and performs the side effects when it is dragged over a drop zone (basically dispatching custom-events scrolling)
    * @param {Set<HTMLElement>} dropZones
    * @param {HTMLElement} draggedEl
    * @param {number} [intervalMs = INTERVAL_MS]
-   * @param {MultiScroller} multiScroller
    */
   function observe(draggedEl, dropZones) {
-    var intervalMs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : INTERVAL_MS;
-    var multiScroller = arguments.length > 3 ? arguments[3] : undefined;
+    var intervalMs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : INTERVAL_MS$1;
     // initialization
     var lastDropZoneFound;
     var lastIndexFound;
@@ -771,10 +822,10 @@
      */
     function andNow() {
       var currentCenterOfDragged = findCenterOfElement(draggedEl);
-      var scrolled = multiScroller.multiScrollIfNeeded();
+      var scrolled = scrollIfNeeded$1(currentCenterOfDragged, lastDropZoneFound);
       // we only want to make a new decision after the element was moved a bit to prevent flickering
       if (!scrolled && lastCentrePositionOfDragged && Math.abs(lastCentrePositionOfDragged.x - currentCenterOfDragged.x) < TOLERANCE_PX && Math.abs(lastCentrePositionOfDragged.y - currentCenterOfDragged.y) < TOLERANCE_PX) {
-        next = window.setTimeout(andNow, intervalMs);
+        next$1 = window.setTimeout(andNow, intervalMs);
         return;
       }
       if (isElementOffDocument(draggedEl)) {
@@ -792,7 +843,7 @@
       try {
         for (_iterator.s(); !(_step = _iterator.n()).done;) {
           var dz = _step.value;
-          if (scrolled) resetIndexesCache();
+          if (scrolled) resetIndexesCacheForDz(lastDropZoneFound);
           var indexObj = findWouldBeIndex(draggedEl, dz);
           if (indexObj === null) {
             // it is not inside
@@ -826,7 +877,7 @@
       } else {
         lastIsDraggedInADropZone = true;
       }
-      next = window.setTimeout(andNow, intervalMs);
+      next$1 = window.setTimeout(andNow, intervalMs);
     }
     andNow();
   }
@@ -836,230 +887,62 @@
     printDebug(function () {
       return "unobserving";
     });
-    clearTimeout(next);
+    clearTimeout(next$1);
+    resetScrolling$1();
     resetIndexesCache();
   }
 
-  var SCROLL_ZONE_PX = 30;
+  var INTERVAL_MS = 300;
+  var mousePosition;
 
   /**
-   * Will make a scroller that can scroll any element given to it in any direction
-   * @returns {{scrollIfNeeded: function(Point, HTMLElement): boolean, resetScrolling: function(void):void}}
+   * Do not use this! it is visible for testing only until we get over the issue Cypress not triggering the mousemove listeners
+   * // TODO - make private (remove export)
+   * @param {{clientX: number, clientY: number}} e
    */
-  function makeScroller() {
-    var scrollingInfo;
-    function resetScrolling() {
-      scrollingInfo = {
-        directionObj: undefined,
-        stepPx: 0
-      };
-    }
-    resetScrolling();
-    // directionObj {x: 0|1|-1, y:0|1|-1} - 1 means down in y and right in x
-    function scrollContainer(containerEl) {
-      var _scrollingInfo = scrollingInfo,
-        directionObj = _scrollingInfo.directionObj,
-        stepPx = _scrollingInfo.stepPx;
-      if (directionObj) {
-        containerEl.scrollBy(directionObj.x * stepPx, directionObj.y * stepPx);
-        window.requestAnimationFrame(function () {
-          return scrollContainer(containerEl);
-        });
-      }
-    }
-    function calcScrollStepPx(distancePx) {
-      return SCROLL_ZONE_PX - distancePx;
-    }
-
-    /**
-     * @param {Point} pointer - the pointer will be used to decide in which direction to scroll
-     * @param {HTMLElement} elementToScroll - the scroll container
-     * If the pointer is next to the sides of the element to scroll, will trigger scrolling
-     * Can be called repeatedly with updated pointer and elementToScroll values without issues
-     * @return {boolean} - true if scrolling was needed
-     */
-    function scrollIfNeeded(pointer, elementToScroll) {
-      if (!elementToScroll) {
-        return false;
-      }
-      var distances = calcInnerDistancesBetweenPointAndSidesOfElement(pointer, elementToScroll);
-      var isAlreadyScrolling = !!scrollingInfo.directionObj;
-      if (distances === null) {
-        if (isAlreadyScrolling) resetScrolling();
-        return false;
-      }
-      var scrollingVertically = false,
-        scrollingHorizontally = false;
-      // vertical
-      if (elementToScroll.scrollHeight > elementToScroll.clientHeight) {
-        if (distances.bottom < SCROLL_ZONE_PX) {
-          scrollingVertically = true;
-          scrollingInfo.directionObj = {
-            x: 0,
-            y: 1
-          };
-          scrollingInfo.stepPx = calcScrollStepPx(distances.bottom);
-        } else if (distances.top < SCROLL_ZONE_PX) {
-          scrollingVertically = true;
-          scrollingInfo.directionObj = {
-            x: 0,
-            y: -1
-          };
-          scrollingInfo.stepPx = calcScrollStepPx(distances.top);
-        }
-        if (!isAlreadyScrolling && scrollingVertically) {
-          scrollContainer(elementToScroll);
-          return true;
-        }
-      }
-      // horizontal
-      if (elementToScroll.scrollWidth > elementToScroll.clientWidth) {
-        if (distances.right < SCROLL_ZONE_PX) {
-          scrollingHorizontally = true;
-          scrollingInfo.directionObj = {
-            x: 1,
-            y: 0
-          };
-          scrollingInfo.stepPx = calcScrollStepPx(distances.right);
-        } else if (distances.left < SCROLL_ZONE_PX) {
-          scrollingHorizontally = true;
-          scrollingInfo.directionObj = {
-            x: -1,
-            y: 0
-          };
-          scrollingInfo.stepPx = calcScrollStepPx(distances.left);
-        }
-        if (!isAlreadyScrolling && scrollingHorizontally) {
-          scrollContainer(elementToScroll);
-          return true;
-        }
-      }
-      resetScrolling();
-      return false;
-    }
-    return {
-      scrollIfNeeded: scrollIfNeeded,
-      resetScrolling: resetScrolling
+  function updateMousePosition(e) {
+    var c = e.touches ? e.touches[0] : e;
+    mousePosition = {
+      x: c.clientX,
+      y: c.clientY
     };
   }
-
-  /**
-   * If the point is inside the element returns its distances from the sides, otherwise returns null
-   * @param {Point} point
-   * @param {HTMLElement} el
-   * @return {null|{top: number, left: number, bottom: number, right: number}}
-   */
-  function calcInnerDistancesBetweenPointAndSidesOfElement(point, el) {
-    // Even if the scrolling element is small it acts as a scroller for the viewport
-    var rect = el === document.scrollingElement ? {
-      top: 0,
-      bottom: window.innerHeight,
-      left: 0,
-      right: window.innerWidth
-    } : el.getBoundingClientRect();
-    if (!isPointInsideRect(point, rect)) {
-      return null;
+  var _makeScroller = makeScroller(),
+    scrollIfNeeded = _makeScroller.scrollIfNeeded,
+    resetScrolling = _makeScroller.resetScrolling;
+  var next;
+  function loop() {
+    if (mousePosition) {
+      var scrolled = scrollIfNeeded(mousePosition, document.documentElement);
+      if (scrolled) resetIndexesCache();
     }
-    return {
-      top: point.y - rect.top,
-      bottom: rect.bottom - point.y,
-      left: point.x - rect.left,
-      right: rect.right - point.x
-    };
+    next = window.setTimeout(loop, INTERVAL_MS);
   }
 
   /**
-   @typedef {Object} MultiScroller
-   @property {function():boolean} multiScrollIfNeeded - call this on every "tick" to scroll containers if needed, returns true if anything was scrolled
-  /**
-   * Creates a scroller than can scroll any of the provided containers or any of their scrollable parents (including the document's scrolling element)
-   * @param {HTMLElement[]} baseElementsForScrolling
-   * @param {function():Point} getPointerPosition
-   * @return {MultiScroller}
+   * will start watching the mouse pointer and scroll the window if it goes next to the edges
    */
-  function createMultiScroller() {
-    var baseElementsForScrolling = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
-    var getPointerPosition = arguments.length > 1 ? arguments[1] : undefined;
+  function armWindowScroller() {
     printDebug(function () {
-      return "creating multi-scroller";
+      return "arming window scroller";
     });
-    var scrollingContainersSet = findRelevantScrollContainers(baseElementsForScrolling);
-    var scrollingContainersDeepToShallow = Array.from(scrollingContainersSet).sort(function (dz1, dz2) {
-      return getDepth(dz2) - getDepth(dz1);
-    });
-    var _makeScroller = makeScroller(),
-      scrollIfNeeded = _makeScroller.scrollIfNeeded,
-      resetScrolling = _makeScroller.resetScrolling;
-
-    /**
-     * @return {boolean} - was any container scrolled
-     */
-    function tick() {
-      var mousePosition = getPointerPosition();
-      if (!mousePosition || !scrollingContainersDeepToShallow) {
-        return false;
-      }
-      var scrollContainersUnderCursor = scrollingContainersDeepToShallow.filter(function (el) {
-        return isPointInsideRect(mousePosition, el.getBoundingClientRect()) || el === document.scrollingElement;
-      });
-      for (var i = 0; i < scrollContainersUnderCursor.length; i++) {
-        var scrolled = scrollIfNeeded(mousePosition, scrollContainersUnderCursor[i]);
-        if (scrolled) {
-          return true;
-        }
-      }
-      return false;
-    }
-    return {
-      multiScrollIfNeeded: scrollingContainersSet.size > 0 ? tick : function () {
-        return false;
-      },
-      destroy: function destroy() {
-        return resetScrolling();
-      }
-    };
+    window.addEventListener("mousemove", updateMousePosition);
+    window.addEventListener("touchmove", updateMousePosition);
+    loop();
   }
 
-  // internal utils
-  function findScrollableParents(element) {
-    if (!element) {
-      return [];
-    }
-    var scrollableContainers = [];
-    var parent = element;
-    while (parent) {
-      var _window$getComputedSt = window.getComputedStyle(parent),
-        overflow = _window$getComputedSt.overflow;
-      if (overflow.split(" ").some(function (o) {
-        return o.includes("auto") || o.includes("scroll");
-      })) {
-        scrollableContainers.push(parent);
-      }
-      parent = parent.parentElement;
-    }
-    return scrollableContainers;
-  }
-  function findRelevantScrollContainers(dropZones) {
-    var scrollingContainers = new Set();
-    var _iterator = _createForOfIteratorHelper(dropZones),
-      _step;
-    try {
-      for (_iterator.s(); !(_step = _iterator.n()).done;) {
-        var dz = _step.value;
-        findScrollableParents(dz).forEach(function (container) {
-          return scrollingContainers.add(container);
-        });
-      }
-      // The scrolling element might have overflow visible and still be scrollable
-    } catch (err) {
-      _iterator.e(err);
-    } finally {
-      _iterator.f();
-    }
-    if (document.scrollingElement.scrollHeight > document.scrollingElement.clientHeight || document.scrollingElement.scrollWidth > document.scrollingElement.clientHeight) {
-      scrollingContainers.add(document.scrollingElement);
-    }
-    return scrollingContainers;
+  /**
+   * will stop watching the mouse pointer and won't scroll the window anymore
+   */
+  function disarmWindowScroller() {
+    printDebug(function () {
+      return "disarming window scroller";
+    });
+    window.removeEventListener("mousemove", updateMousePosition);
+    window.removeEventListener("touchmove", updateMousePosition);
+    mousePosition = undefined;
+    window.clearTimeout(next);
+    resetScrolling();
   }
 
   /**
@@ -1067,15 +950,15 @@
    * Since svelte manages select value internally.
    * @see https://github.com/sveltejs/svelte/issues/6717
    * @see https://github.com/isaacHagoel/svelte-dnd-action/issues/306
-   *
-   * @param {HTMLElement} el
-   * @returns
+   * 
+   * @param {HTMLElement} el 
+   * @returns 
    */
   function svelteNodeClone(el) {
     var cloned = el.cloneNode(true);
     var values = [];
     var elIsSelect = el.tagName === "SELECT";
-    var selects = elIsSelect ? [el] : _toConsumableArray(el.querySelectorAll("select"));
+    var selects = elIsSelect ? [el] : _toConsumableArray(el.querySelectorAll('select'));
     var _iterator = _createForOfIteratorHelper(selects),
       _step;
     try {
@@ -1088,62 +971,21 @@
     } finally {
       _iterator.f();
     }
-    if (selects.length > 0) {
-      var clonedSelects = elIsSelect ? [cloned] : _toConsumableArray(cloned.querySelectorAll("select"));
-      for (var i = 0; i < clonedSelects.length; i++) {
-        var select = clonedSelects[i];
-        var value = values[i];
-        var optionEl = select.querySelector("option[value=\"".concat(value, "\""));
-        if (optionEl) {
-          optionEl.setAttribute("selected", true);
-        }
-      }
+    if (selects.length <= 0) {
+      return cloned;
     }
-    var elIsCanvas = el.tagName === "CANVAS";
-    var canvases = elIsCanvas ? [el] : _toConsumableArray(el.querySelectorAll("canvas"));
-    if (canvases.length > 0) {
-      var clonedCanvases = elIsCanvas ? [cloned] : _toConsumableArray(cloned.querySelectorAll("canvas"));
-      for (var _i = 0; _i < clonedCanvases.length; _i++) {
-        var canvas = canvases[_i];
-        var clonedCanvas = clonedCanvases[_i];
-        clonedCanvas.width = canvas.width;
-        clonedCanvas.height = canvas.height;
-        if (canvas.width > 0 && canvas.height > 0) {
-          clonedCanvas.getContext("2d").drawImage(canvas, 0, 0);
-        }
+    var clonedSelects = elIsSelect ? [cloned] : _toConsumableArray(cloned.querySelectorAll('select'));
+    for (var i = 0; i < clonedSelects.length; i++) {
+      var select = clonedSelects[i];
+      var value = values[i];
+      var optionEl = select.querySelector("option[value=\"".concat(value, "\""));
+      if (optionEl) {
+        optionEl.setAttribute('selected', true);
       }
     }
     return cloned;
   }
 
-  /**
-   * @type {{USE_COMPUTED_STYLE_INSTEAD_OF_BOUNDING_RECT: string}}
-   */
-  var FEATURE_FLAG_NAMES = Object.freeze({
-    // This flag exists as a workaround for issue 454 (basically a browser bug) - seems like these rect values take time to update when in grid layout. Setting it to true can cause strange behaviour in the REPL for non-grid zones, see issue 470
-    USE_COMPUTED_STYLE_INSTEAD_OF_BOUNDING_RECT: "USE_COMPUTED_STYLE_INSTEAD_OF_BOUNDING_RECT"
-  });
-  var featureFlagsMap = _defineProperty({}, FEATURE_FLAG_NAMES.USE_COMPUTED_STYLE_INSTEAD_OF_BOUNDING_RECT, false);
-
-  /**
-   * @param {FEATURE_FLAG_NAMES} flagName
-   * @param {boolean} flagValue
-   */
-  function setFeatureFlag(flagName, flagValue) {
-    if (!FEATURE_FLAG_NAMES[flagName]) throw new Error("Can't set non existing feature flag ".concat(flagName, "! Supported flags: ").concat(Object.keys(FEATURE_FLAG_NAMES)));
-    featureFlagsMap[flagName] = !!flagValue;
-  }
-
-  /**
-   *
-   * @param {FEATURE_FLAG_NAMES} flagName
-   * @return {boolean}
-   */
-  function getFeatureFlag(flagName) {
-    if (!FEATURE_FLAG_NAMES[flagName]) throw new Error("Can't get non existing feature flag ".concat(flagName, "! Supported flags: ").concat(Object.keys(FEATURE_FLAG_NAMES)));
-    return featureFlagsMap[flagName];
-  }
-
   var TRANSITION_DURATION_SECONDS = 0.2;
 
   /**
@@ -1220,10 +1062,8 @@
         left: (currentMouseX - draggedElRect.left) / draggedElRect.width,
         top: (currentMouseY - draggedElRect.top) / draggedElRect.height
       };
-      if (!getFeatureFlag(FEATURE_FLAG_NAMES.USE_COMPUTED_STYLE_INSTEAD_OF_BOUNDING_RECT)) {
-        draggedEl.style.height = "".concat(newRect.height, "px");
-        draggedEl.style.width = "".concat(newRect.width, "px");
-      }
+      draggedEl.style.height = "".concat(newRect.height, "px");
+      draggedEl.style.width = "".concat(newRect.width, "px");
       draggedEl.style.left = "".concat(parseFloat(draggedEl.style.left) - relativeDistanceOfMousePointerFromDraggedSides.left * widthChange, "px");
       draggedEl.style.top = "".concat(parseFloat(draggedEl.style.top) - relativeDistanceOfMousePointerFromDraggedSides.top * heightChange, "px");
     }
@@ -1236,9 +1076,7 @@
   function copyStylesFromTo(copyFromEl, copyToEl) {
     var computedStyle = window.getComputedStyle(copyFromEl);
     Array.from(computedStyle).filter(function (s) {
-      return s.startsWith("background") || s.startsWith("padding") || s.startsWith("font") || s.startsWith("text") || s.startsWith("align") || s.startsWith("justify") || s.startsWith("display") || s.startsWith("flex") || s.startsWith("border") || s === "opacity" || s === "color" || s === "list-style-type" ||
-      // copying with and height to make up for rect update timing issues in some browsers
-      getFeatureFlag(FEATURE_FLAG_NAMES.USE_COMPUTED_STYLE_INSTEAD_OF_BOUNDING_RECT) && (s === "width" || s === "height");
+      return s.startsWith("background") || s.startsWith("padding") || s.startsWith("font") || s.startsWith("text") || s.startsWith("align") || s.startsWith("justify") || s.startsWith("display") || s.startsWith("flex") || s.startsWith("border") || s === "opacity" || s === "color" || s === "list-style-type";
     }).forEach(function (s) {
       return copyToEl.style.setProperty(s, computedStyle.getPropertyValue(s), computedStyle.getPropertyPriority(s));
     });
@@ -1355,13 +1193,10 @@
 
   var DEFAULT_DROP_ZONE_TYPE$1 = "--any--";
   var MIN_OBSERVATION_INTERVAL_MS = 100;
-  var DISABLED_OBSERVATION_INTERVAL_MS = 20;
   var MIN_MOVEMENT_BEFORE_DRAG_START_PX = 3;
-  var DEFAULT_TOUCH_DELAY_MS = 80;
   var DEFAULT_DROP_TARGET_STYLE$1 = {
     outline: "rgba(255, 255, 102, 0.7) solid 2px"
   };
-  var ORIGINAL_DRAGGED_ITEM_MARKER_ATTRIBUTE = "data-is-dnd-original-dragged-item";
   var originalDragTarget;
   var draggedEl;
   var draggedElData;
@@ -1377,9 +1212,6 @@
   var unlockOriginDzMinDimensions;
   var isDraggedOutsideOfAnyDz = false;
   var scheduledForRemovalAfterDrop = [];
-  var multiScroller;
-  var touchDragHoldTimer;
-  var touchHoldElapsed = false;
 
   // a map from type to a set of drop-zones
   var typeToDropZones$1 = new Map();
@@ -1414,6 +1246,7 @@
     printDebug(function () {
       return "watching dragged element";
     });
+    armWindowScroller();
     var dropZones = typeToDropZones$1.get(draggedElType);
     var _iterator = _createForOfIteratorHelper(dropZones),
       _step;
@@ -1430,21 +1263,17 @@
       _iterator.f();
     }
     window.addEventListener(DRAGGED_LEFT_DOCUMENT_EVENT_NAME, handleDrop$1);
-
     // it is important that we don't have an interval that is faster than the flip duration because it can cause elements to jump bach and forth
-    var setIntervalMs = Math.max.apply(Math, _toConsumableArray(Array.from(dropZones.keys()).map(function (dz) {
+    var observationIntervalMs = Math.max.apply(Math, [MIN_OBSERVATION_INTERVAL_MS].concat(_toConsumableArray(Array.from(dropZones.keys()).map(function (dz) {
       return dzToConfig$1.get(dz).dropAnimationDurationMs;
-    })));
-    var observationIntervalMs = setIntervalMs === 0 ? DISABLED_OBSERVATION_INTERVAL_MS : Math.max(setIntervalMs, MIN_OBSERVATION_INTERVAL_MS); // if setIntervalMs is 0 it goes to 20, otherwise it is max between it and min observation.
-    multiScroller = createMultiScroller(dropZones, function () {
-      return currentMousePosition;
-    });
-    observe(draggedEl, dropZones, observationIntervalMs * 1.07, multiScroller);
+    }))));
+    observe(draggedEl, dropZones, observationIntervalMs * 1.07);
   }
   function unWatchDraggedElement() {
     printDebug(function () {
       return "unwatching dragged element";
     });
+    disarmWindowScroller();
     var dropZones = typeToDropZones$1.get(draggedElType);
     var _iterator2 = _createForOfIteratorHelper(dropZones),
       _step2;
@@ -1461,21 +1290,20 @@
       _iterator2.f();
     }
     window.removeEventListener(DRAGGED_LEFT_DOCUMENT_EVENT_NAME, handleDrop$1);
-    // ensuring multiScroller is not already destroyed before destroying
-    if (multiScroller) {
-      multiScroller.destroy();
-      multiScroller = undefined;
-    }
     unobserve();
   }
-  function findShadowElementIdx(items) {
+
+  // finds the initial placeholder that is placed there on drag start
+  function findShadowPlaceHolderIdx(items) {
     return items.findIndex(function (item) {
-      return !!item[SHADOW_ITEM_MARKER_PROPERTY_NAME];
+      return item[ITEM_ID_KEY] === SHADOW_PLACEHOLDER_ITEM_ID;
     });
   }
-  function createShadowElData(draggedElData) {
-    var _objectSpread2$1;
-    return _objectSpread2(_objectSpread2({}, draggedElData), {}, (_objectSpread2$1 = {}, _defineProperty(_objectSpread2$1, SHADOW_ITEM_MARKER_PROPERTY_NAME, true), _defineProperty(_objectSpread2$1, ITEM_ID_KEY, SHADOW_PLACEHOLDER_ITEM_ID), _objectSpread2$1));
+  function findShadowElementIdx(items) {
+    // checking that the id is not the placeholder's for Dragula like usecases
+    return items.findIndex(function (item) {
+      return !!item[SHADOW_ITEM_MARKER_PROPERTY_NAME] && item[ITEM_ID_KEY] !== SHADOW_PLACEHOLDER_ITEM_ID;
+    });
   }
 
   /* custom drag-events handlers */
@@ -1510,8 +1338,20 @@
         id: draggedElData[ITEM_ID_KEY],
         source: SOURCES.POINTER
       });
+    } else {
+      var shadowPlaceHolderIdx = findShadowPlaceHolderIdx(items);
+      if (shadowPlaceHolderIdx !== -1) {
+        // only happens right after drag start, on the first drag entered event
+        printDebug(function () {
+          return "removing placeholder item from origin dz";
+        });
+        items.splice(shadowPlaceHolderIdx, 1);
+      }
     }
-    var shadowElIdx = e.detail.indexObj.index;
+    var _e$detail$indexObj = e.detail.indexObj,
+      index = _e$detail$indexObj.index,
+      isProximityBased = _e$detail$indexObj.isProximityBased;
+    var shadowElIdx = isProximityBased && index === e.currentTarget.children.length - 1 ? index + 1 : index;
     shadowElDropZone = e.currentTarget;
     items.splice(shadowElIdx, 0, shadowElData);
     dispatchConsiderEvent(e.currentTarget, items, {
@@ -1527,7 +1367,7 @@
       return ["dragged left", e.currentTarget, e.detail];
     });
     var _dzToConfig$get2 = dzToConfig$1.get(e.currentTarget),
-      originalItems = _dzToConfig$get2.items,
+      items = _dzToConfig$get2.items,
       dropFromOthersDisabled = _dzToConfig$get2.dropFromOthersDisabled;
     if (dropFromOthersDisabled && e.currentTarget !== originDropZone && e.currentTarget !== shadowElDropZone) {
       printDebug(function () {
@@ -1535,12 +1375,8 @@
       });
       return;
     }
-    var items = _toConsumableArray(originalItems);
     var shadowElIdx = findShadowElementIdx(items);
-    if (shadowElIdx !== -1) {
-      items.splice(shadowElIdx, 1);
-    }
-    var origShadowDz = shadowElDropZone;
+    var shadowItem = items.splice(shadowElIdx, 1)[0];
     shadowElDropZone = undefined;
     var _e$detail = e.detail,
       type = _e$detail.type,
@@ -1551,9 +1387,8 @@
       });
       isDraggedOutsideOfAnyDz = true;
       shadowElDropZone = originDropZone;
-      // if the last zone it left is the origin dz, we will put it back into items (which we just removed it from)
-      var originZoneItems = origShadowDz === originDropZone ? items : _toConsumableArray(dzToConfig$1.get(originDropZone).items);
-      originZoneItems.splice(originIndex, 0, shadowElData);
+      var originZoneItems = dzToConfig$1.get(originDropZone).items;
+      originZoneItems.splice(originIndex, 0, shadowItem);
       dispatchConsiderEvent(originDropZone, originZoneItems, {
         trigger: TRIGGERS.DRAGGED_LEFT_ALL,
         id: draggedElData[ITEM_ID_KEY],
@@ -1572,7 +1407,7 @@
       return ["dragged is over index", e.currentTarget, e.detail];
     });
     var _dzToConfig$get3 = dzToConfig$1.get(e.currentTarget),
-      originalItems = _dzToConfig$get3.items,
+      items = _dzToConfig$get3.items,
       dropFromOthersDisabled = _dzToConfig$get3.dropFromOthersDisabled;
     if (dropFromOthersDisabled && e.currentTarget !== originDropZone) {
       printDebug(function () {
@@ -1580,13 +1415,10 @@
       });
       return;
     }
-    var items = _toConsumableArray(originalItems);
     isDraggedOutsideOfAnyDz = false;
     var index = e.detail.indexObj.index;
     var shadowElIdx = findShadowElementIdx(items);
-    if (shadowElIdx !== -1) {
-      items.splice(shadowElIdx, 1);
-    }
+    items.splice(shadowElIdx, 1);
     items.splice(index, 0, shadowElData);
     dispatchConsiderEvent(e.currentTarget, items, {
       trigger: TRIGGERS.DRAGGED_OVER_INDEX,
@@ -1599,9 +1431,12 @@
   function handleMouseMove(e) {
     e.preventDefault();
     var c = e.touches ? e.touches[0] : e;
+    var _dzToConfig$get4 = dzToConfig$1.get(originDropZone),
+      constrainAxisX = _dzToConfig$get4.constrainAxisX,
+      constrainAxisY = _dzToConfig$get4.constrainAxisY;
     currentMousePosition = {
-      x: c.clientX,
-      y: c.clientY
+      x: constrainAxisX ? dragStartMousePosition.x : c.clientX,
+      y: constrainAxisY ? dragStartMousePosition.y : c.clientY
     };
     draggedEl.style.transform = "translate3d(".concat(currentMousePosition.x - dragStartMousePosition.x, "px, ").concat(currentMousePosition.y - dragStartMousePosition.y, "px, 0)");
   }
@@ -1626,9 +1461,9 @@
     printDebug(function () {
       return ["dropped in dz", shadowElDropZone];
     });
-    var _dzToConfig$get4 = dzToConfig$1.get(shadowElDropZone),
-      items = _dzToConfig$get4.items,
-      type = _dzToConfig$get4.type;
+    var _dzToConfig$get5 = dzToConfig$1.get(shadowElDropZone),
+      items = _dzToConfig$get5.items,
+      type = _dzToConfig$get5.type;
     styleInactiveDropZones(typeToDropZones$1.get(type), function (dz) {
       return dzToConfig$1.get(dz).dropTargetStyle;
     }, function (dz) {
@@ -1636,11 +1471,7 @@
     });
     var shadowElIdx = findShadowElementIdx(items);
     // the handler might remove the shadow element, ex: dragula like copy on drag
-    if (shadowElIdx === -1) {
-      if (shadowElDropZone === originDropZone) {
-        shadowElIdx = originIndex;
-      }
-    }
+    if (shadowElIdx === -1) shadowElIdx = originIndex;
     items = items.map(function (item) {
       return item[SHADOW_ITEM_MARKER_PROPERTY_NAME] ? draggedElData : item;
     });
@@ -1659,29 +1490,21 @@
           source: SOURCES.POINTER
         });
       }
-      // In edge cases the dom might have not been updated yet so we can't rely on data list index
-      var domShadowEl = Array.from(shadowElDropZone.children).find(function (c) {
-        return c.getAttribute(SHADOW_ELEMENT_ATTRIBUTE_NAME);
-      });
-      if (domShadowEl) unDecorateShadowElement(domShadowEl);
+      unDecorateShadowElement(shadowElDropZone.children[shadowElIdx]);
       cleanupPostDrop();
     }
-    if (dzToConfig$1.get(shadowElDropZone).dropAnimationDisabled) {
-      finalizeWithinZone();
-    } else {
-      animateDraggedToFinalPosition(shadowElIdx, finalizeWithinZone);
-    }
+    animateDraggedToFinalPosition(shadowElIdx, finalizeWithinZone);
   }
 
   // helper function for handleDrop
   function animateDraggedToFinalPosition(shadowElIdx, callback) {
-    var shadowElRect = shadowElIdx > -1 ? getBoundingRectNoTransforms(shadowElDropZone.children[shadowElIdx], false) : getBoundingRectNoTransforms(shadowElDropZone, false);
+    var shadowElRect = getBoundingRectNoTransforms(shadowElDropZone.children[shadowElIdx]);
     var newTransform = {
       x: shadowElRect.left - parseFloat(draggedEl.style.left),
       y: shadowElRect.top - parseFloat(draggedEl.style.top)
     };
-    var _dzToConfig$get5 = dzToConfig$1.get(shadowElDropZone),
-      dropAnimationDurationMs = _dzToConfig$get5.dropAnimationDurationMs;
+    var _dzToConfig$get6 = dzToConfig$1.get(shadowElDropZone),
+      dropAnimationDurationMs = _dzToConfig$get6.dropAnimationDurationMs;
     var transition = "transform ".concat(dropAnimationDurationMs, "ms ease");
     draggedEl.style.transition = draggedEl.style.transition ? draggedEl.style.transition + "," + transition : transition;
     draggedEl.style.transform = "translate3d(".concat(newTransform.x, "px, ").concat(newTransform.y, "px, 0)");
@@ -1699,12 +1522,19 @@
   }
   /* cleanup */
   function cleanupPostDrop() {
-    // Remove the temporary elements that were kept in the DOM during the drag
-    if (draggedEl && draggedEl.remove) {
-      draggedEl.remove();
-    }
-    if (originalDragTarget && originalDragTarget.remove) {
-      originalDragTarget.remove();
+    draggedEl.remove();
+    originalDragTarget.remove();
+    if (scheduledForRemovalAfterDrop.length) {
+      printDebug(function () {
+        return ["will destroy zones that were removed during drag", scheduledForRemovalAfterDrop];
+      });
+      scheduledForRemovalAfterDrop.forEach(function (_ref) {
+        var dz = _ref.dz,
+          destroy = _ref.destroy;
+        destroy();
+        dz.remove();
+      });
+      scheduledForRemovalAfterDrop = [];
     }
     draggedEl = undefined;
     originalDragTarget = undefined;
@@ -1720,23 +1550,6 @@
     finalizingPreviousDrag = false;
     unlockOriginDzMinDimensions = undefined;
     isDraggedOutsideOfAnyDz = false;
-    if (touchDragHoldTimer) {
-      clearTimeout(touchDragHoldTimer);
-    }
-    touchDragHoldTimer = undefined;
-    touchHoldElapsed = false;
-    if (scheduledForRemovalAfterDrop.length) {
-      printDebug(function () {
-        return ["will destroy zones that were removed during drag", scheduledForRemovalAfterDrop];
-      });
-      scheduledForRemovalAfterDrop.forEach(function (_ref) {
-        var dz = _ref.dz,
-          destroy = _ref.destroy;
-        destroy();
-        dz.remove();
-      });
-      scheduledForRemovalAfterDrop = [];
-    }
   }
   function dndzone$2(node, options) {
     var initialized = false;
@@ -1744,15 +1557,15 @@
       items: undefined,
       type: undefined,
       flipDurationMs: 0,
+      constrainAxisX: false,
+      constrainAxisY: false,
       dragDisabled: false,
       morphDisabled: false,
       dropFromOthersDisabled: false,
       dropTargetStyle: DEFAULT_DROP_TARGET_STYLE$1,
       dropTargetClasses: [],
       transformDraggedElement: function transformDraggedElement() {},
-      centreDraggedOnCursor: false,
-      dropAnimationDisabled: false,
-      delayTouchStartMs: 0
+      centreDraggedOnCursor: false
     };
     printDebug(function () {
       return ["dndzone good to go options: ".concat(toString(options), ", config: ").concat(toString(config)), {
@@ -1780,52 +1593,16 @@
       window.removeEventListener("touchmove", handleMouseMoveMaybeDragStart);
       window.removeEventListener("mouseup", handleFalseAlarm);
       window.removeEventListener("touchend", handleFalseAlarm);
-      if (touchDragHoldTimer) {
-        clearTimeout(touchDragHoldTimer);
-        touchDragHoldTimer = undefined;
-        touchHoldElapsed = false;
-      }
     }
-    function handleFalseAlarm(e) {
+    function handleFalseAlarm() {
       removeMaybeListeners();
       originalDragTarget = undefined;
       dragStartMousePosition = undefined;
       currentMousePosition = undefined;
-
-      // dragging initiated by touch events prevents onclick from initially firing
-      if (e.type === "touchend") {
-        var clickEvent = new Event("click", {
-          bubbles: true,
-          cancelable: true
-        });
-        // doing it this way instead of calling .click() because that doesn't work for SVG elements
-        e.target.dispatchEvent(clickEvent);
-      }
     }
     function handleMouseMoveMaybeDragStart(e) {
-      var isTouch = !!e.touches;
-      var c = isTouch ? e.touches[0] : e;
-      // If touch drag delay is configured and not elapsed yet, allow scrolling until either
-      // the delay elapses (timer will call handleDragStart) or the user moves significantly,
-      // in which case we cancel the potential drag and let the interaction be a scroll.
-      if (isTouch && config.delayTouchStartMs > 0 && !touchHoldElapsed) {
-        currentMousePosition = {
-          x: c.clientX,
-          y: c.clientY
-        };
-        if (Math.abs(currentMousePosition.x - dragStartMousePosition.x) >= MIN_MOVEMENT_BEFORE_DRAG_START_PX || Math.abs(currentMousePosition.y - dragStartMousePosition.y) >= MIN_MOVEMENT_BEFORE_DRAG_START_PX) {
-          // User started scrolling, cancel drag attempt.
-          if (touchDragHoldTimer) {
-            clearTimeout(touchDragHoldTimer);
-            touchDragHoldTimer = undefined;
-          }
-          handleFalseAlarm(e);
-        }
-        return; // Do not preventDefault so scrolling works.
-      }
-
-      // legacy / post-delay path – block scrolling and maybe start drag
       e.preventDefault();
+      var c = e.touches ? e.touches[0] : e;
       currentMousePosition = {
         x: c.clientX,
         y: c.clientY
@@ -1856,29 +1633,14 @@
         });
         return;
       }
-      var isTouchStart = !!e.touches;
-      var useDelay = isTouchStart && config.delayTouchStartMs > 0;
-      if (!useDelay) {
-        e.preventDefault();
-      }
       e.stopPropagation();
-      var c = isTouchStart ? e.touches[0] : e;
+      var c = e.touches ? e.touches[0] : e;
       dragStartMousePosition = {
         x: c.clientX,
         y: c.clientY
       };
       currentMousePosition = _objectSpread2({}, dragStartMousePosition);
       originalDragTarget = e.currentTarget;
-      if (useDelay) {
-        touchHoldElapsed = false;
-        touchDragHoldTimer = window.setTimeout(function () {
-          // If the finger is still down and no false-alarm happened
-          if (!originalDragTarget) return;
-          touchHoldElapsed = true;
-          removeMaybeListeners();
-          handleDragStart();
-        }, config.delayTouchStartMs);
-      }
       addMaybeListeners();
     }
     function handleDragStart() {
@@ -1891,32 +1653,29 @@
       var currentIdx = elToIdx.get(originalDragTarget);
       originIndex = currentIdx;
       originDropZone = originalDragTarget.parentElement;
-      /** @type {ShadowRoot | HTMLDocument | Element } */
-      var rootNode = originDropZone.closest("dialog") || originDropZone.closest("[popover]") || originDropZone.getRootNode();
+      /** @type {ShadowRoot | HTMLDocument} */
+      var rootNode = originDropZone.getRootNode();
       var originDropZoneRoot = rootNode.body || rootNode;
-      var originalItems = config.items,
+      var items = config.items,
         type = config.type,
         centreDraggedOnCursor = config.centreDraggedOnCursor;
-      var items = _toConsumableArray(originalItems);
-      draggedElData = items[currentIdx];
+      draggedElData = _objectSpread2({}, items[currentIdx]);
       draggedElType = type;
-      shadowElData = createShadowElData(draggedElData);
+      shadowElData = _objectSpread2(_objectSpread2({}, draggedElData), {}, _defineProperty({}, SHADOW_ITEM_MARKER_PROPERTY_NAME, true));
+      // The initial shadow element. We need a different id at first in order to avoid conflicts and timing issues
+      var placeHolderElData = _objectSpread2(_objectSpread2({}, shadowElData), {}, _defineProperty({}, ITEM_ID_KEY, SHADOW_PLACEHOLDER_ITEM_ID));
 
       // creating the draggable element
       draggedEl = createDraggedElementFrom(originalDragTarget, centreDraggedOnCursor && currentMousePosition);
-      originDropZoneRoot.appendChild(draggedEl);
       // We will keep the original dom node in the dom because touch events keep firing on it, we want to re-add it after the framework removes it
       function keepOriginalElementInDom() {
-        if (!originalDragTarget.parentElement) {
-          originalDragTarget.setAttribute(ORIGINAL_DRAGGED_ITEM_MARKER_ATTRIBUTE, true);
-          originDropZoneRoot.appendChild(originalDragTarget);
-          // have to watch before we hide, otherwise Svelte 5 $state gets confused
-          watchDraggedElement();
-          hideElement(originalDragTarget);
-          // after the removal of the original element we can give the shadow element the original item id so that the host zone can find it and render it correctly if it does lookups by id
-          shadowElData[ITEM_ID_KEY] = draggedElData[ITEM_ID_KEY];
+        if (!draggedEl.parentElement) {
+          originDropZoneRoot.appendChild(draggedEl);
           // to prevent the outline from disappearing
           draggedEl.focus();
+          watchDraggedElement();
+          hideElement(originalDragTarget);
+          originDropZoneRoot.appendChild(originalDragTarget);
         } else {
           window.requestAnimationFrame(keepOriginalElementInDom);
         }
@@ -1931,7 +1690,7 @@
       });
 
       // removing the original element by removing its data entry
-      items.splice(currentIdx, 1, shadowElData);
+      items.splice(currentIdx, 1, placeHolderElData);
       unlockOriginDzMinDimensions = preventShrinking(originDropZone);
       dispatchConsiderEvent(originDropZone, items, {
         trigger: TRIGGERS.DRAG_STARTED,
@@ -1961,6 +1720,10 @@
         dropAnimationDurationMs = _ref2$flipDurationMs === void 0 ? 0 : _ref2$flipDurationMs,
         _ref2$type = _ref2.type,
         newType = _ref2$type === void 0 ? DEFAULT_DROP_ZONE_TYPE$1 : _ref2$type,
+        _ref2$constrainAxisX = _ref2.constrainAxisX,
+        constrainAxisX = _ref2$constrainAxisX === void 0 ? false : _ref2$constrainAxisX,
+        _ref2$constrainAxisY = _ref2.constrainAxisY,
+        constrainAxisY = _ref2$constrainAxisY === void 0 ? false : _ref2$constrainAxisY,
         _ref2$dragDisabled = _ref2.dragDisabled,
         dragDisabled = _ref2$dragDisabled === void 0 ? false : _ref2$dragDisabled,
         _ref2$morphDisabled = _ref2.morphDisabled,
@@ -1974,29 +1737,20 @@
         _ref2$transformDragge = _ref2.transformDraggedElement,
         transformDraggedElement = _ref2$transformDragge === void 0 ? function () {} : _ref2$transformDragge,
         _ref2$centreDraggedOn = _ref2.centreDraggedOnCursor,
-        centreDraggedOnCursor = _ref2$centreDraggedOn === void 0 ? false : _ref2$centreDraggedOn,
-        _ref2$dropAnimationDi = _ref2.dropAnimationDisabled,
-        dropAnimationDisabled = _ref2$dropAnimationDi === void 0 ? false : _ref2$dropAnimationDi,
-        _ref2$delayTouchStart = _ref2.delayTouchStart,
-        delayTouchStartOpt = _ref2$delayTouchStart === void 0 ? false : _ref2$delayTouchStart;
+        centreDraggedOnCursor = _ref2$centreDraggedOn === void 0 ? false : _ref2$centreDraggedOn;
       config.dropAnimationDurationMs = dropAnimationDurationMs;
-      var effectiveDelayMs = 0;
-      if (delayTouchStartOpt === true) {
-        effectiveDelayMs = DEFAULT_TOUCH_DELAY_MS;
-      } else if (typeof delayTouchStartOpt === "number" && isFinite(delayTouchStartOpt) && delayTouchStartOpt >= 0) {
-        effectiveDelayMs = delayTouchStartOpt;
-      }
-      config.delayTouchStartMs = effectiveDelayMs;
       if (config.type && newType !== config.type) {
         unregisterDropZone$1(node, config.type);
       }
       config.type = newType;
+      registerDropZone$1(node, newType);
       config.items = _toConsumableArray(items);
+      config.constrainAxisX = constrainAxisX;
+      config.constrainAxisY = constrainAxisY;
       config.dragDisabled = dragDisabled;
       config.morphDisabled = morphDisabled;
       config.transformDraggedElement = transformDraggedElement;
       config.centreDraggedOnCursor = centreDraggedOnCursor;
-      config.dropAnimationDisabled = dropAnimationDisabled;
 
       // realtime update for dropTargetStyle
       if (initialized && isWorkingOnPreviousDrag && !finalizingPreviousDrag && (!areObjectsShallowEqual(dropTargetStyle, config.dropTargetStyle) || !areArraysShallowEqualSameOrder(dropTargetClasses, config.dropTargetClasses))) {
@@ -2035,16 +1789,15 @@
       }
       config.dropFromOthersDisabled = dropFromOthersDisabled;
       dzToConfig$1.set(node, config);
-      registerDropZone$1(node, newType);
-      var shadowElIdx = isWorkingOnPreviousDrag ? findShadowElementIdx(config.items) : -1;
+      var shadowElIdx = findShadowElementIdx(config.items);
       for (var idx = 0; idx < node.children.length; idx++) {
         var draggableEl = node.children[idx];
         styleDraggable(draggableEl, dragDisabled);
         if (idx === shadowElIdx) {
+          config.transformDraggedElement(draggedEl, draggedElData, idx);
           if (!morphDisabled) {
             morphDraggedElementToBeLike(draggedEl, draggableEl, currentMousePosition.x, currentMousePosition.y);
           }
-          config.transformDraggedElement(draggedEl, draggedElData, idx);
           decorateShadowEl(draggableEl);
           continue;
         }
@@ -2078,7 +1831,7 @@
           unregisterDropZone$1(node, dzToConfig$1.get(node).type);
           dzToConfig$1["delete"](node);
         }
-        if (isWorkingOnPreviousDrag && !node.closest("[".concat(ORIGINAL_DRAGGED_ITEM_MARKER_ATTRIBUTE, "]"))) {
+        if (isWorkingOnPreviousDrag) {
           printDebug(function () {
             return "pointer dndzone will be scheduled for destruction";
           });
@@ -2356,7 +2109,6 @@
       type: undefined,
       dragDisabled: false,
       zoneTabIndex: 0,
-      zoneItemTabIndex: 0,
       dropFromOthersDisabled: false,
       dropTargetStyle: DEFAULT_DROP_TARGET_STYLE,
       dropTargetClasses: [],
@@ -2486,7 +2238,7 @@
       var children = Array.from(node.children);
       var focusedItemIdx = children.indexOf(draggableEl);
       focusedItem = draggableEl;
-      focusedItem.tabIndex = config.zoneItemTabIndex;
+      focusedItem.tabIndex = 0;
       focusedItemId = items[focusedItemIdx][ITEM_ID_KEY];
       focusedItemLabel = children[focusedItemIdx].getAttribute("aria-label") || "";
     }
@@ -2499,8 +2251,6 @@
         dragDisabled = _ref2$dragDisabled === void 0 ? false : _ref2$dragDisabled,
         _ref2$zoneTabIndex = _ref2.zoneTabIndex,
         zoneTabIndex = _ref2$zoneTabIndex === void 0 ? 0 : _ref2$zoneTabIndex,
-        _ref2$zoneItemTabInde = _ref2.zoneItemTabIndex,
-        zoneItemTabIndex = _ref2$zoneItemTabInde === void 0 ? 0 : _ref2$zoneItemTabInde,
         _ref2$dropFromOthersD = _ref2.dropFromOthersDisabled,
         dropFromOthersDisabled = _ref2$dropFromOthersD === void 0 ? false : _ref2$dropFromOthersD,
         _ref2$dropTargetStyle = _ref2.dropTargetStyle,
@@ -2513,7 +2263,6 @@
       config.dragDisabled = dragDisabled;
       config.dropFromOthersDisabled = dropFromOthersDisabled;
       config.zoneTabIndex = zoneTabIndex;
-      config.zoneItemTabIndex = zoneItemTabIndex;
       config.dropTargetStyle = dropTargetStyle;
       config.dropTargetClasses = dropTargetClasses;
       config.autoAriaDisabled = autoAriaDisabled;
@@ -2537,7 +2286,7 @@
       var _loop = function _loop(i) {
         var draggableEl = node.children[i];
         allDragTargets.add(draggableEl);
-        draggableEl.tabIndex = isDragging ? -1 : config.zoneItemTabIndex;
+        draggableEl.tabIndex = isDragging ? -1 : 0;
         if (!autoAriaDisabled) {
           draggableEl.setAttribute("role", "listitem");
         }
@@ -2558,7 +2307,7 @@
           });
           // if it is a nested dropzone, it was re-rendered and we need to refresh our pointer
           focusedItem = draggableEl;
-          focusedItem.tabIndex = config.zoneItemTabIndex;
+          focusedItem.tabIndex = 0;
           // without this the element loses focus if it moves backwards in the list
           draggableEl.focus();
         }
@@ -2588,7 +2337,7 @@
     return handles;
   }
 
-  var _excluded = ["items", "flipDurationMs", "type", "dragDisabled", "morphDisabled", "dropFromOthersDisabled", "zoneTabIndex", "zoneItemTabIndex", "dropTargetStyle", "dropTargetClasses", "transformDraggedElement", "autoAriaDisabled", "centreDraggedOnCursor", "delayTouchStart", "dropAnimationDisabled"];
+  var _excluded = ["items", "flipDurationMs", "type", "constrainAxisX", "constrainAxisY", "dragDisabled", "morphDisabled", "dropFromOthersDisabled", "zoneTabIndex", "dropTargetStyle", "dropTargetClasses", "transformDraggedElement", "autoAriaDisabled", "centreDraggedOnCursor"];
 
   /**
    * A custom action to turn any container to a dnd zone and all of its direct children to draggables
@@ -2600,28 +2349,20 @@
    * @property {array} items - the list of items that was used to generate the children of the given node (the list used in the #each block
    * @property {string} [type] - the type of the dnd zone. children dragged from here can only be dropped in other zones of the same type, default to a base type
    * @property {number} [flipDurationMs] - if the list animated using flip (recommended), specifies the flip duration such that everything syncs with it without conflict, defaults to zero
+   * @property {boolean} [constrainAxisX] - Constrain dragging by X axis. Drag will be allowed only by Y axis.
+   * @property {boolean} [constrainAxisY] - Constrain dragging by Y axis. Drag will be allowed only by X axis.
    * @property {boolean} [dragDisabled]
    * @property {boolean} [morphDisabled] - whether dragged element should morph to zone dimensions
    * @property {boolean} [dropFromOthersDisabled]
    * @property {number} [zoneTabIndex] - set the tabindex of the list container when not dragging
-   * @property {number} [zoneItemTabIndex] - set the tabindex of the list container items when not dragging
    * @property {object} [dropTargetStyle]
    * @property {string[]} [dropTargetClasses]
-   * @property {boolean|number} [delayTouchStart] - On touch devices, wait this long before converting the gesture to a drag.
-   * `true` uses the built-in default (80 ms).
-   * @property {boolean} [dropAnimationDisabled] - cancels the drop animation to place
    * @property {function} [transformDraggedElement]
    * @param {HTMLElement} node - the element to enhance
    * @param {Options} options
    * @return {{update: function, destroy: function}}
    */
   function dndzone(node, options) {
-    if (shouldIgnoreZone(node)) {
-      return {
-        update: function update() {},
-        destroy: function destroy() {}
-      };
-    }
     validateOptions(options);
     var pointerZone = dndzone$2(node, options);
     var keyboardZone = dndzone$1(node, options);
@@ -2637,33 +2378,22 @@
       }
     };
   }
-
-  /**
-   * If the user marked something in the ancestry of our node as shadow element, we can ignore it
-   * We need the user to mark it for us because svelte updates the action from deep to shallow (but renders top down)
-   * @param {HTMLElement} node
-   * @return {boolean}
-   */
-  function shouldIgnoreZone(node) {
-    return !!node.closest("[".concat(SHADOW_ELEMENT_HINT_ATTRIBUTE_NAME, "=\"true\"]"));
-  }
   function validateOptions(options) {
     /*eslint-disable*/
     var items = options.items;
       options.flipDurationMs;
       options.type;
+      options.constrainAxisX;
+      options.constrainAxisY;
       options.dragDisabled;
       options.morphDisabled;
       options.dropFromOthersDisabled;
-      var zoneTabIndex = options.zoneTabIndex,
-      zoneItemTabIndex = options.zoneItemTabIndex;
+      var zoneTabIndex = options.zoneTabIndex;
       options.dropTargetStyle;
       var dropTargetClasses = options.dropTargetClasses;
       options.transformDraggedElement;
       options.autoAriaDisabled;
       options.centreDraggedOnCursor;
-      var delayTouchStart = options.delayTouchStart;
-      options.dropAnimationDisabled;
       var rest = _objectWithoutProperties(options, _excluded);
     /*eslint-enable*/
     if (Object.keys(rest).length > 0) {
@@ -2684,16 +2414,6 @@
     if (zoneTabIndex && !isInt(zoneTabIndex)) {
       throw new Error("zoneTabIndex should be a number but instead it is a ".concat(_typeof(zoneTabIndex), ", ").concat(toString(zoneTabIndex)));
     }
-    if (zoneItemTabIndex && !isInt(zoneItemTabIndex)) {
-      throw new Error("zoneItemTabIndex should be a number but instead it is a ".concat(_typeof(zoneItemTabIndex), ", ").concat(toString(zoneItemTabIndex)));
-    }
-    if (delayTouchStart !== undefined && delayTouchStart !== false) {
-      var validBoolean = delayTouchStart === true;
-      var validNumber = typeof delayTouchStart === "number" && isFinite(delayTouchStart) && delayTouchStart >= 0;
-      if (!validBoolean && !validNumber) {
-        throw new Error("delayTouchStart should be a boolean (true/false) or a non-negative number but instead it is a ".concat(_typeof(delayTouchStart), ", ").concat(toString(delayTouchStart)));
-      }
-    }
   }
   function isInt(value) {
     return !isNaN(value) && function (x) {
@@ -2701,165 +2421,15 @@
     }(parseFloat(value));
   }
 
-  function createStore(initialValue) {
-    var _val = initialValue;
-    var subs = new Set();
-    return {
-      get: function get() {
-        return _val;
-      },
-      set: function set(newVal) {
-        _val = newVal;
-        Array.from(subs).forEach(function (cb) {
-          return cb(_val);
-        });
-      },
-      subscribe: function subscribe(cb) {
-        subs.add(cb);
-        cb(_val);
-      },
-      unsubscribe: function unsubscribe(cb) {
-        subs["delete"](cb);
-      }
-    };
-  }
-
-  var isItemsDragDisabled = createStore(true);
-  var userDragDisabled = createStore(false);
-  function getAddedOptions() {
-    return {
-      dragDisabled: userDragDisabled.get() || isItemsDragDisabled.get(),
-      zoneItemTabIndex: -1
-    };
-  }
-
-  /**
-   * This is an action that wraps around the dndzone action to make it easy to work with drag handles
-   * When using this you must also use the 'dragHandle' action (see below) on an element inside each item within the zone
-   * Credit for the idea and initial implementation goes to @gleuch (Greg Leuch) and @geovie (Georg Vienna)
-   *
-   * @param {HTMLElement} node
-   * @param options - will be passed down to the dndzone
-   * @return {{update: (newOptions: Object) => {}, destroy: () => {}}}
-   */
-  function dragHandleZone(node, options) {
-    var _options$dragDisabled;
-    // Initialise stores from initial options
-    userDragDisabled.set((_options$dragDisabled = options === null || options === void 0 ? void 0 : options.dragDisabled) !== null && _options$dragDisabled !== void 0 ? _options$dragDisabled : false);
-    var currentOptions = options;
-    var zone = dndzone(node, _objectSpread2(_objectSpread2({}, currentOptions), getAddedOptions()));
-    function updateZone() {
-      zone.update(_objectSpread2(_objectSpread2({}, currentOptions), getAddedOptions()));
-    }
-
-    // Subscribe to internal store so finishing a drag updates the zone
-    isItemsDragDisabled.subscribe(updateZone);
-
-    // We don't need to subscribe to userDragDisabled here because updates to
-    // it always come through the `update` lifecycle and will call `updateZone`
-    // anyway.
-
-    function consider(e) {
-      var _e$detail$info = e.detail.info,
-        source = _e$detail$info.source,
-        trigger = _e$detail$info.trigger;
-      // Ensure dragging is stopped on drag finish via keyboard
-      if (source === SOURCES.KEYBOARD && trigger === TRIGGERS.DRAG_STOPPED) {
-        isItemsDragDisabled.set(true);
-      }
-    }
-    function finalize(e) {
-      var source = e.detail.info.source;
-      // Ensure dragging is stopped on drag finish via pointer (mouse, touch)
-      if (source === SOURCES.POINTER) {
-        isItemsDragDisabled.set(true);
-      }
-    }
-    node.addEventListener("consider", consider);
-    node.addEventListener("finalize", finalize);
-    return {
-      update: function update(newOptions) {
-        var _currentOptions$dragD, _currentOptions;
-        currentOptions = newOptions;
-        // keep store in sync with external prop
-        userDragDisabled.set((_currentOptions$dragD = (_currentOptions = currentOptions) === null || _currentOptions === void 0 ? void 0 : _currentOptions.dragDisabled) !== null && _currentOptions$dragD !== void 0 ? _currentOptions$dragD : false);
-        updateZone();
-      },
-      destroy: function destroy() {
-        node.removeEventListener("consider", consider);
-        node.removeEventListener("finalize", finalize);
-        isItemsDragDisabled.unsubscribe(updateZone);
-      }
-    };
-  }
-
-  /**
-   * This should be used to mark drag handles inside items that belong to a 'dragHandleZone' (see above)
-   * @param {HTMLElement} handle
-   * @return {{update: *, destroy: *}}
-   */
-  function dragHandle(handle) {
-    handle.setAttribute("role", "button");
-    function startDrag(e) {
-      // preventing default to prevent lag on touch devices (because of the browser checking for screen scrolling)
-      e.preventDefault();
-      isItemsDragDisabled.set(false);
-
-      // Reset the startDrag/isItemsDragDisabled if the user releases the mouse/touch without initiating a drag
-      window.addEventListener("mouseup", resetStartDrag);
-      window.addEventListener("touchend", resetStartDrag);
-    }
-    function handleKeyDown(e) {
-      if (e.key === "Enter" || e.key === " ") isItemsDragDisabled.set(false);
-    }
-    function resetStartDrag() {
-      isItemsDragDisabled.set(true);
-      window.removeEventListener("mouseup", resetStartDrag);
-      window.removeEventListener("touchend", resetStartDrag);
-    }
-    var recomputeHandleState = function recomputeHandleState() {
-      var userDisabled = userDragDisabled.get();
-      var internalDisabled = isItemsDragDisabled.get();
-      if (userDisabled) {
-        handle.tabIndex = -1;
-        handle.style.cursor = ""; // default cursor
-      } else {
-        handle.tabIndex = internalDisabled ? 0 : -1;
-        handle.style.cursor = internalDisabled ? "grab" : "grabbing";
-      }
-    };
-
-    // Subscribe to both stores
-    userDragDisabled.subscribe(recomputeHandleState);
-    isItemsDragDisabled.subscribe(recomputeHandleState);
-    handle.addEventListener("mousedown", startDrag);
-    handle.addEventListener("touchstart", startDrag);
-    handle.addEventListener("keydown", handleKeyDown);
-    return {
-      update: function update() {},
-      destroy: function destroy() {
-        handle.removeEventListener("mousedown", startDrag);
-        handle.removeEventListener("touchstart", startDrag);
-        handle.removeEventListener("keydown", handleKeyDown);
-        userDragDisabled.unsubscribe(recomputeHandleState);
-        isItemsDragDisabled.unsubscribe(recomputeHandleState);
-      }
-    };
-  }
-
   exports.DRAGGED_ELEMENT_ID = DRAGGED_ELEMENT_ID;
-  exports.FEATURE_FLAG_NAMES = FEATURE_FLAG_NAMES;
   exports.SHADOW_ITEM_MARKER_PROPERTY_NAME = SHADOW_ITEM_MARKER_PROPERTY_NAME;
   exports.SHADOW_PLACEHOLDER_ITEM_ID = SHADOW_PLACEHOLDER_ITEM_ID;
   exports.SOURCES = SOURCES;
   exports.TRIGGERS = TRIGGERS;
   exports.alertToScreenReader = alertToScreenReader;
   exports.dndzone = dndzone;
-  exports.dragHandle = dragHandle;
-  exports.dragHandleZone = dragHandleZone;
   exports.overrideItemIdKeyNameBeforeInitialisingDndZones = overrideItemIdKeyNameBeforeInitialisingDndZones;
   exports.setDebugMode = setDebugMode;
-  exports.setFeatureFlag = setFeatureFlag;
 
   Object.defineProperty(exports, '__esModule', { value: true });
 
diff --git a/dist/index.mjs b/dist/index.mjs
index f48ea5f23aa3547cd68e6541aacabac3504bf0a5..a03b368f5d5bc683331a383e10598cfc8ea99090 100644
--- a/dist/index.mjs
+++ b/dist/index.mjs
@@ -288,8 +288,7 @@ var SOURCES = {
   KEYBOARD: "keyboard"
 };
 var SHADOW_ITEM_MARKER_PROPERTY_NAME = "isDndShadowItem";
-var SHADOW_ELEMENT_ATTRIBUTE_NAME = "data-is-dnd-shadow-item-internal";
-var SHADOW_ELEMENT_HINT_ATTRIBUTE_NAME = "data-is-dnd-shadow-item-hint";
+var SHADOW_ELEMENT_ATTRIBUTE_NAME = "data-is-dnd-shadow-item";
 var SHADOW_PLACEHOLDER_ITEM_ID = "id:dnd-shadow-placeholder-0000";
 var DRAGGED_ELEMENT_ID = "dnd-action-dragged-el";
 var ITEM_ID_KEY = "id";
@@ -327,7 +326,7 @@ var printDebug = function printDebug() {};
 
 /**
  * Allows the user to show/hide console debug output
- * * @param {boolean} isDebug
+ * * @param {Boolean} isDebug
  */
 function setDebugMode(isDebug) {
   if (isDebug) {
@@ -350,13 +349,11 @@ function setDebugMode(isDebug) {
 /**
  * Gets the bounding rect but removes transforms (ex: flip animation)
  * @param {HTMLElement} el
- * @param {boolean} [onlyVisible] - use the visible rect defaults to true
  * @return {{top: number, left: number, bottom: number, right: number}}
  */
 function getBoundingRectNoTransforms(el) {
-  var onlyVisible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
   var ta;
-  var rect = onlyVisible ? getVisibleRectRecursive(el) : el.getBoundingClientRect();
+  var rect = el.getBoundingClientRect();
   var style = getComputedStyle(el);
   var tx = style.transform;
   if (tx) {
@@ -497,58 +494,30 @@ function calcDistanceBetweenCenters(elA, elB) {
 
 /**
  * @param {HTMLElement} el - the element to check
- * @returns {boolean} - true if the element in its entirety is off-screen including the scrollable area (the normal dom events look at the mouse rather than the element)
+ * @returns {boolean} - true if the element in its entirety is off screen including the scrollable area (the normal dom events look at the mouse rather than the element)
  */
 function isElementOffDocument(el) {
   var rect = getAbsoluteRect(el);
   return rect.right < 0 || rect.left > document.documentElement.scrollWidth || rect.bottom < 0 || rect.top > document.documentElement.scrollHeight;
 }
-function getVisibleRectRecursive(element) {
-  var rect = element.getBoundingClientRect();
-  var visibleRect = {
-    top: rect.top,
-    bottom: rect.bottom,
-    left: rect.left,
-    right: rect.right
-  };
 
-  // Traverse up the DOM hierarchy, checking for scrollable ancestors
-  var parent = element.parentElement;
-  while (parent && parent !== document.body) {
-    var parentRect = parent.getBoundingClientRect();
-
-    // Check if the parent has a scrollable overflow
-    var overflowY = window.getComputedStyle(parent).overflowY;
-    var overflowX = window.getComputedStyle(parent).overflowX;
-    var isScrollableY = overflowY === "scroll" || overflowY === "auto";
-    var isScrollableX = overflowX === "scroll" || overflowX === "auto";
-
-    // Constrain the visible area to the parent's visible area
-    if (isScrollableY) {
-      visibleRect.top = Math.max(visibleRect.top, parentRect.top);
-      visibleRect.bottom = Math.min(visibleRect.bottom, parentRect.bottom);
-    }
-    if (isScrollableX) {
-      visibleRect.left = Math.max(visibleRect.left, parentRect.left);
-      visibleRect.right = Math.min(visibleRect.right, parentRect.right);
-    }
-    parent = parent.parentElement;
+/**
+ * If the point is inside the element returns its distances from the sides, otherwise returns null
+ * @param {Point} point
+ * @param {HTMLElement} el
+ * @return {null|{top: number, left: number, bottom: number, right: number}}
+ */
+function calcInnerDistancesBetweenPointAndSidesOfElement(point, el) {
+  var rect = getAbsoluteRect(el);
+  if (!isPointInsideRect(point, rect)) {
+    return null;
   }
-
-  // Finally, constrain the visible rect to the viewport
-  visibleRect.top = Math.max(visibleRect.top, 0);
-  visibleRect.bottom = Math.min(visibleRect.bottom, window.innerHeight);
-  visibleRect.left = Math.max(visibleRect.left, 0);
-  visibleRect.right = Math.min(visibleRect.right, window.innerWidth);
-
-  // Return the visible rectangle, ensuring that all values are valid
   return {
-    top: visibleRect.top,
-    bottom: visibleRect.bottom,
-    left: visibleRect.left,
-    right: visibleRect.right,
-    width: Math.max(0, visibleRect.right - visibleRect.left),
-    height: Math.max(0, visibleRect.bottom - visibleRect.top)
+    top: point.y - rect.top,
+    bottom: rect.bottom - point.y,
+    left: point.x - rect.left,
+    // TODO - figure out what is so special about right (why the rect is too big)
+    right: Math.min(rect.right, document.documentElement.clientWidth) - point.x
   };
 }
 
@@ -565,6 +534,17 @@ function resetIndexesCache() {
 }
 resetIndexesCache();
 
+/**
+ * Resets the cache that allows for smarter "would be index" resolution for a specific dropzone, should be called after the zone was scrolled
+ * @param {HTMLElement} dz
+ */
+function resetIndexesCacheForDz(dz) {
+  printDebug(function () {
+    return "resetting indexes cache for dz";
+  });
+  dzToShadowIndexToRect["delete"](dz);
+}
+
 /**
  * Caches the coordinates of the shadow element when it's in a certain index in a certain dropzone.
  * Helpful in order to determine "would be index" more effectively
@@ -641,35 +621,105 @@ function findWouldBeIndex(floatingAboveEl, collectionBelowEl) {
       indexOfMin = _i;
     }
   }
+  return {
+    index: indexOfMin,
+    isProximityBased: true
+  };
+}
 
-  // -------- Phantom slot check --------
-  // Regardless of layout (simple vertical list, flex-wrap, grid, floats …) the
-  // visually closest drop target can be *after* the current last **real** child.
-  // In simple layouts the would be index from the existing children would always be the last index
-  // but in more complex layouts (flex-wrap, grid, floats …) it can be any index.
-  // The problem is we can't predict where an additional element would be rendered in the general case,
-  // We therefore create a temporary, invisible clone of that last element, let
-  // the browser position it, measure the distance, and remove it immediately
-  // (same task → no paint).  This leaves `children` back in its original state
-  // before we exit the function, so existing index-caching logic and shadow-
-  // element bookkeeping continue to work unchanged.
-  if (children.length > 0) {
-    var originalLen = children.length; // before we append the phantom
-    var template = children[originalLen - 1];
-    var phantom = template.cloneNode(false); // shallow clone is enough for size
-    phantom.style.visibility = "hidden";
-    phantom.style.pointerEvents = "none";
-    collectionBelowEl.appendChild(phantom);
-    var phantomDistance = calcDistanceBetweenCenters(floatingAboveEl, phantom);
-    if (phantomDistance < minDistanceSoFar) {
-      indexOfMin = originalLen; // index of phantom slot in original list
+var SCROLL_ZONE_PX = 25;
+function makeScroller() {
+  var scrollingInfo;
+  function resetScrolling() {
+    scrollingInfo = {
+      directionObj: undefined,
+      stepPx: 0
+    };
+  }
+  resetScrolling();
+  // directionObj {x: 0|1|-1, y:0|1|-1} - 1 means down in y and right in x
+  function scrollContainer(containerEl) {
+    var _scrollingInfo = scrollingInfo,
+      directionObj = _scrollingInfo.directionObj,
+      stepPx = _scrollingInfo.stepPx;
+    if (directionObj) {
+      containerEl.scrollBy(directionObj.x * stepPx, directionObj.y * stepPx);
+      window.requestAnimationFrame(function () {
+        return scrollContainer(containerEl);
+      });
     }
+  }
+  function calcScrollStepPx(distancePx) {
+    return SCROLL_ZONE_PX - distancePx;
+  }
 
-    collectionBelowEl.removeChild(phantom);
+  /**
+   * If the pointer is next to the sides of the element to scroll, will trigger scrolling
+   * Can be called repeatedly with updated pointer and elementToScroll values without issues
+   * @return {boolean} - true if scrolling was needed
+   */
+  function scrollIfNeeded(pointer, elementToScroll) {
+    if (!elementToScroll) {
+      return false;
+    }
+    var distances = calcInnerDistancesBetweenPointAndSidesOfElement(pointer, elementToScroll);
+    if (distances === null) {
+      resetScrolling();
+      return false;
+    }
+    var isAlreadyScrolling = !!scrollingInfo.directionObj;
+    var scrollingVertically = false,
+      scrollingHorizontally = false;
+    // vertical
+    if (elementToScroll.scrollHeight > elementToScroll.clientHeight) {
+      if (distances.bottom < SCROLL_ZONE_PX) {
+        scrollingVertically = true;
+        scrollingInfo.directionObj = {
+          x: 0,
+          y: 1
+        };
+        scrollingInfo.stepPx = calcScrollStepPx(distances.bottom);
+      } else if (distances.top < SCROLL_ZONE_PX) {
+        scrollingVertically = true;
+        scrollingInfo.directionObj = {
+          x: 0,
+          y: -1
+        };
+        scrollingInfo.stepPx = calcScrollStepPx(distances.top);
+      }
+      if (!isAlreadyScrolling && scrollingVertically) {
+        scrollContainer(elementToScroll);
+        return true;
+      }
+    }
+    // horizontal
+    if (elementToScroll.scrollWidth > elementToScroll.clientWidth) {
+      if (distances.right < SCROLL_ZONE_PX) {
+        scrollingHorizontally = true;
+        scrollingInfo.directionObj = {
+          x: 1,
+          y: 0
+        };
+        scrollingInfo.stepPx = calcScrollStepPx(distances.right);
+      } else if (distances.left < SCROLL_ZONE_PX) {
+        scrollingHorizontally = true;
+        scrollingInfo.directionObj = {
+          x: -1,
+          y: 0
+        };
+        scrollingInfo.stepPx = calcScrollStepPx(distances.left);
+      }
+      if (!isAlreadyScrolling && scrollingHorizontally) {
+        scrollContainer(elementToScroll);
+        return true;
+      }
+    }
+    resetScrolling();
+    return false;
   }
   return {
-    index: indexOfMin,
-    isProximityBased: true
+    scrollIfNeeded: scrollIfNeeded,
+    resetScrolling: resetScrolling
   };
 }
 
@@ -736,20 +786,21 @@ function areArraysShallowEqualSameOrder(arrA, arrB) {
   return true;
 }
 
-var INTERVAL_MS = 200;
+var INTERVAL_MS$1 = 200;
 var TOLERANCE_PX = 10;
-var next;
+var _makeScroller$1 = makeScroller(),
+  scrollIfNeeded$1 = _makeScroller$1.scrollIfNeeded,
+  resetScrolling$1 = _makeScroller$1.resetScrolling;
+var next$1;
 
 /**
  * Tracks the dragged elements and performs the side effects when it is dragged over a drop zone (basically dispatching custom-events scrolling)
  * @param {Set<HTMLElement>} dropZones
  * @param {HTMLElement} draggedEl
  * @param {number} [intervalMs = INTERVAL_MS]
- * @param {MultiScroller} multiScroller
  */
 function observe(draggedEl, dropZones) {
-  var intervalMs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : INTERVAL_MS;
-  var multiScroller = arguments.length > 3 ? arguments[3] : undefined;
+  var intervalMs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : INTERVAL_MS$1;
   // initialization
   var lastDropZoneFound;
   var lastIndexFound;
@@ -765,10 +816,10 @@ function observe(draggedEl, dropZones) {
    */
   function andNow() {
     var currentCenterOfDragged = findCenterOfElement(draggedEl);
-    var scrolled = multiScroller.multiScrollIfNeeded();
+    var scrolled = scrollIfNeeded$1(currentCenterOfDragged, lastDropZoneFound);
     // we only want to make a new decision after the element was moved a bit to prevent flickering
     if (!scrolled && lastCentrePositionOfDragged && Math.abs(lastCentrePositionOfDragged.x - currentCenterOfDragged.x) < TOLERANCE_PX && Math.abs(lastCentrePositionOfDragged.y - currentCenterOfDragged.y) < TOLERANCE_PX) {
-      next = window.setTimeout(andNow, intervalMs);
+      next$1 = window.setTimeout(andNow, intervalMs);
       return;
     }
     if (isElementOffDocument(draggedEl)) {
@@ -786,7 +837,7 @@ function observe(draggedEl, dropZones) {
     try {
       for (_iterator.s(); !(_step = _iterator.n()).done;) {
         var dz = _step.value;
-        if (scrolled) resetIndexesCache();
+        if (scrolled) resetIndexesCacheForDz(lastDropZoneFound);
         var indexObj = findWouldBeIndex(draggedEl, dz);
         if (indexObj === null) {
           // it is not inside
@@ -820,7 +871,7 @@ function observe(draggedEl, dropZones) {
     } else {
       lastIsDraggedInADropZone = true;
     }
-    next = window.setTimeout(andNow, intervalMs);
+    next$1 = window.setTimeout(andNow, intervalMs);
   }
   andNow();
 }
@@ -830,230 +881,62 @@ function unobserve() {
   printDebug(function () {
     return "unobserving";
   });
-  clearTimeout(next);
+  clearTimeout(next$1);
+  resetScrolling$1();
   resetIndexesCache();
 }
 
-var SCROLL_ZONE_PX = 30;
+var INTERVAL_MS = 300;
+var mousePosition;
 
 /**
- * Will make a scroller that can scroll any element given to it in any direction
- * @returns {{scrollIfNeeded: function(Point, HTMLElement): boolean, resetScrolling: function(void):void}}
+ * Do not use this! it is visible for testing only until we get over the issue Cypress not triggering the mousemove listeners
+ * // TODO - make private (remove export)
+ * @param {{clientX: number, clientY: number}} e
  */
-function makeScroller() {
-  var scrollingInfo;
-  function resetScrolling() {
-    scrollingInfo = {
-      directionObj: undefined,
-      stepPx: 0
-    };
-  }
-  resetScrolling();
-  // directionObj {x: 0|1|-1, y:0|1|-1} - 1 means down in y and right in x
-  function scrollContainer(containerEl) {
-    var _scrollingInfo = scrollingInfo,
-      directionObj = _scrollingInfo.directionObj,
-      stepPx = _scrollingInfo.stepPx;
-    if (directionObj) {
-      containerEl.scrollBy(directionObj.x * stepPx, directionObj.y * stepPx);
-      window.requestAnimationFrame(function () {
-        return scrollContainer(containerEl);
-      });
-    }
-  }
-  function calcScrollStepPx(distancePx) {
-    return SCROLL_ZONE_PX - distancePx;
-  }
-
-  /**
-   * @param {Point} pointer - the pointer will be used to decide in which direction to scroll
-   * @param {HTMLElement} elementToScroll - the scroll container
-   * If the pointer is next to the sides of the element to scroll, will trigger scrolling
-   * Can be called repeatedly with updated pointer and elementToScroll values without issues
-   * @return {boolean} - true if scrolling was needed
-   */
-  function scrollIfNeeded(pointer, elementToScroll) {
-    if (!elementToScroll) {
-      return false;
-    }
-    var distances = calcInnerDistancesBetweenPointAndSidesOfElement(pointer, elementToScroll);
-    var isAlreadyScrolling = !!scrollingInfo.directionObj;
-    if (distances === null) {
-      if (isAlreadyScrolling) resetScrolling();
-      return false;
-    }
-    var scrollingVertically = false,
-      scrollingHorizontally = false;
-    // vertical
-    if (elementToScroll.scrollHeight > elementToScroll.clientHeight) {
-      if (distances.bottom < SCROLL_ZONE_PX) {
-        scrollingVertically = true;
-        scrollingInfo.directionObj = {
-          x: 0,
-          y: 1
-        };
-        scrollingInfo.stepPx = calcScrollStepPx(distances.bottom);
-      } else if (distances.top < SCROLL_ZONE_PX) {
-        scrollingVertically = true;
-        scrollingInfo.directionObj = {
-          x: 0,
-          y: -1
-        };
-        scrollingInfo.stepPx = calcScrollStepPx(distances.top);
-      }
-      if (!isAlreadyScrolling && scrollingVertically) {
-        scrollContainer(elementToScroll);
-        return true;
-      }
-    }
-    // horizontal
-    if (elementToScroll.scrollWidth > elementToScroll.clientWidth) {
-      if (distances.right < SCROLL_ZONE_PX) {
-        scrollingHorizontally = true;
-        scrollingInfo.directionObj = {
-          x: 1,
-          y: 0
-        };
-        scrollingInfo.stepPx = calcScrollStepPx(distances.right);
-      } else if (distances.left < SCROLL_ZONE_PX) {
-        scrollingHorizontally = true;
-        scrollingInfo.directionObj = {
-          x: -1,
-          y: 0
-        };
-        scrollingInfo.stepPx = calcScrollStepPx(distances.left);
-      }
-      if (!isAlreadyScrolling && scrollingHorizontally) {
-        scrollContainer(elementToScroll);
-        return true;
-      }
-    }
-    resetScrolling();
-    return false;
-  }
-  return {
-    scrollIfNeeded: scrollIfNeeded,
-    resetScrolling: resetScrolling
+function updateMousePosition(e) {
+  var c = e.touches ? e.touches[0] : e;
+  mousePosition = {
+    x: c.clientX,
+    y: c.clientY
   };
 }
-
-/**
- * If the point is inside the element returns its distances from the sides, otherwise returns null
- * @param {Point} point
- * @param {HTMLElement} el
- * @return {null|{top: number, left: number, bottom: number, right: number}}
- */
-function calcInnerDistancesBetweenPointAndSidesOfElement(point, el) {
-  // Even if the scrolling element is small it acts as a scroller for the viewport
-  var rect = el === document.scrollingElement ? {
-    top: 0,
-    bottom: window.innerHeight,
-    left: 0,
-    right: window.innerWidth
-  } : el.getBoundingClientRect();
-  if (!isPointInsideRect(point, rect)) {
-    return null;
+var _makeScroller = makeScroller(),
+  scrollIfNeeded = _makeScroller.scrollIfNeeded,
+  resetScrolling = _makeScroller.resetScrolling;
+var next;
+function loop() {
+  if (mousePosition) {
+    var scrolled = scrollIfNeeded(mousePosition, document.documentElement);
+    if (scrolled) resetIndexesCache();
   }
-  return {
-    top: point.y - rect.top,
-    bottom: rect.bottom - point.y,
-    left: point.x - rect.left,
-    right: rect.right - point.x
-  };
+  next = window.setTimeout(loop, INTERVAL_MS);
 }
 
 /**
- @typedef {Object} MultiScroller
- @property {function():boolean} multiScrollIfNeeded - call this on every "tick" to scroll containers if needed, returns true if anything was scrolled
-/**
- * Creates a scroller than can scroll any of the provided containers or any of their scrollable parents (including the document's scrolling element)
- * @param {HTMLElement[]} baseElementsForScrolling
- * @param {function():Point} getPointerPosition
- * @return {MultiScroller}
+ * will start watching the mouse pointer and scroll the window if it goes next to the edges
  */
-function createMultiScroller() {
-  var baseElementsForScrolling = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
-  var getPointerPosition = arguments.length > 1 ? arguments[1] : undefined;
+function armWindowScroller() {
   printDebug(function () {
-    return "creating multi-scroller";
+    return "arming window scroller";
   });
-  var scrollingContainersSet = findRelevantScrollContainers(baseElementsForScrolling);
-  var scrollingContainersDeepToShallow = Array.from(scrollingContainersSet).sort(function (dz1, dz2) {
-    return getDepth(dz2) - getDepth(dz1);
-  });
-  var _makeScroller = makeScroller(),
-    scrollIfNeeded = _makeScroller.scrollIfNeeded,
-    resetScrolling = _makeScroller.resetScrolling;
-
-  /**
-   * @return {boolean} - was any container scrolled
-   */
-  function tick() {
-    var mousePosition = getPointerPosition();
-    if (!mousePosition || !scrollingContainersDeepToShallow) {
-      return false;
-    }
-    var scrollContainersUnderCursor = scrollingContainersDeepToShallow.filter(function (el) {
-      return isPointInsideRect(mousePosition, el.getBoundingClientRect()) || el === document.scrollingElement;
-    });
-    for (var i = 0; i < scrollContainersUnderCursor.length; i++) {
-      var scrolled = scrollIfNeeded(mousePosition, scrollContainersUnderCursor[i]);
-      if (scrolled) {
-        return true;
-      }
-    }
-    return false;
-  }
-  return {
-    multiScrollIfNeeded: scrollingContainersSet.size > 0 ? tick : function () {
-      return false;
-    },
-    destroy: function destroy() {
-      return resetScrolling();
-    }
-  };
+  window.addEventListener("mousemove", updateMousePosition);
+  window.addEventListener("touchmove", updateMousePosition);
+  loop();
 }
 
-// internal utils
-function findScrollableParents(element) {
-  if (!element) {
-    return [];
-  }
-  var scrollableContainers = [];
-  var parent = element;
-  while (parent) {
-    var _window$getComputedSt = window.getComputedStyle(parent),
-      overflow = _window$getComputedSt.overflow;
-    if (overflow.split(" ").some(function (o) {
-      return o.includes("auto") || o.includes("scroll");
-    })) {
-      scrollableContainers.push(parent);
-    }
-    parent = parent.parentElement;
-  }
-  return scrollableContainers;
-}
-function findRelevantScrollContainers(dropZones) {
-  var scrollingContainers = new Set();
-  var _iterator = _createForOfIteratorHelper(dropZones),
-    _step;
-  try {
-    for (_iterator.s(); !(_step = _iterator.n()).done;) {
-      var dz = _step.value;
-      findScrollableParents(dz).forEach(function (container) {
-        return scrollingContainers.add(container);
-      });
-    }
-    // The scrolling element might have overflow visible and still be scrollable
-  } catch (err) {
-    _iterator.e(err);
-  } finally {
-    _iterator.f();
-  }
-  if (document.scrollingElement.scrollHeight > document.scrollingElement.clientHeight || document.scrollingElement.scrollWidth > document.scrollingElement.clientHeight) {
-    scrollingContainers.add(document.scrollingElement);
-  }
-  return scrollingContainers;
+/**
+ * will stop watching the mouse pointer and won't scroll the window anymore
+ */
+function disarmWindowScroller() {
+  printDebug(function () {
+    return "disarming window scroller";
+  });
+  window.removeEventListener("mousemove", updateMousePosition);
+  window.removeEventListener("touchmove", updateMousePosition);
+  mousePosition = undefined;
+  window.clearTimeout(next);
+  resetScrolling();
 }
 
 /**
@@ -1061,15 +944,15 @@ function findRelevantScrollContainers(dropZones) {
  * Since svelte manages select value internally.
  * @see https://github.com/sveltejs/svelte/issues/6717
  * @see https://github.com/isaacHagoel/svelte-dnd-action/issues/306
- *
- * @param {HTMLElement} el
- * @returns
+ * 
+ * @param {HTMLElement} el 
+ * @returns 
  */
 function svelteNodeClone(el) {
   var cloned = el.cloneNode(true);
   var values = [];
   var elIsSelect = el.tagName === "SELECT";
-  var selects = elIsSelect ? [el] : _toConsumableArray(el.querySelectorAll("select"));
+  var selects = elIsSelect ? [el] : _toConsumableArray(el.querySelectorAll('select'));
   var _iterator = _createForOfIteratorHelper(selects),
     _step;
   try {
@@ -1082,62 +965,21 @@ function svelteNodeClone(el) {
   } finally {
     _iterator.f();
   }
-  if (selects.length > 0) {
-    var clonedSelects = elIsSelect ? [cloned] : _toConsumableArray(cloned.querySelectorAll("select"));
-    for (var i = 0; i < clonedSelects.length; i++) {
-      var select = clonedSelects[i];
-      var value = values[i];
-      var optionEl = select.querySelector("option[value=\"".concat(value, "\""));
-      if (optionEl) {
-        optionEl.setAttribute("selected", true);
-      }
-    }
+  if (selects.length <= 0) {
+    return cloned;
   }
-  var elIsCanvas = el.tagName === "CANVAS";
-  var canvases = elIsCanvas ? [el] : _toConsumableArray(el.querySelectorAll("canvas"));
-  if (canvases.length > 0) {
-    var clonedCanvases = elIsCanvas ? [cloned] : _toConsumableArray(cloned.querySelectorAll("canvas"));
-    for (var _i = 0; _i < clonedCanvases.length; _i++) {
-      var canvas = canvases[_i];
-      var clonedCanvas = clonedCanvases[_i];
-      clonedCanvas.width = canvas.width;
-      clonedCanvas.height = canvas.height;
-      if (canvas.width > 0 && canvas.height > 0) {
-        clonedCanvas.getContext("2d").drawImage(canvas, 0, 0);
-      }
+  var clonedSelects = elIsSelect ? [cloned] : _toConsumableArray(cloned.querySelectorAll('select'));
+  for (var i = 0; i < clonedSelects.length; i++) {
+    var select = clonedSelects[i];
+    var value = values[i];
+    var optionEl = select.querySelector("option[value=\"".concat(value, "\""));
+    if (optionEl) {
+      optionEl.setAttribute('selected', true);
     }
   }
   return cloned;
 }
 
-/**
- * @type {{USE_COMPUTED_STYLE_INSTEAD_OF_BOUNDING_RECT: string}}
- */
-var FEATURE_FLAG_NAMES = Object.freeze({
-  // This flag exists as a workaround for issue 454 (basically a browser bug) - seems like these rect values take time to update when in grid layout. Setting it to true can cause strange behaviour in the REPL for non-grid zones, see issue 470
-  USE_COMPUTED_STYLE_INSTEAD_OF_BOUNDING_RECT: "USE_COMPUTED_STYLE_INSTEAD_OF_BOUNDING_RECT"
-});
-var featureFlagsMap = _defineProperty({}, FEATURE_FLAG_NAMES.USE_COMPUTED_STYLE_INSTEAD_OF_BOUNDING_RECT, false);
-
-/**
- * @param {FEATURE_FLAG_NAMES} flagName
- * @param {boolean} flagValue
- */
-function setFeatureFlag(flagName, flagValue) {
-  if (!FEATURE_FLAG_NAMES[flagName]) throw new Error("Can't set non existing feature flag ".concat(flagName, "! Supported flags: ").concat(Object.keys(FEATURE_FLAG_NAMES)));
-  featureFlagsMap[flagName] = !!flagValue;
-}
-
-/**
- *
- * @param {FEATURE_FLAG_NAMES} flagName
- * @return {boolean}
- */
-function getFeatureFlag(flagName) {
-  if (!FEATURE_FLAG_NAMES[flagName]) throw new Error("Can't get non existing feature flag ".concat(flagName, "! Supported flags: ").concat(Object.keys(FEATURE_FLAG_NAMES)));
-  return featureFlagsMap[flagName];
-}
-
 var TRANSITION_DURATION_SECONDS = 0.2;
 
 /**
@@ -1214,10 +1056,8 @@ function morphDraggedElementToBeLike(draggedEl, copyFromEl, currentMouseX, curre
       left: (currentMouseX - draggedElRect.left) / draggedElRect.width,
       top: (currentMouseY - draggedElRect.top) / draggedElRect.height
     };
-    if (!getFeatureFlag(FEATURE_FLAG_NAMES.USE_COMPUTED_STYLE_INSTEAD_OF_BOUNDING_RECT)) {
-      draggedEl.style.height = "".concat(newRect.height, "px");
-      draggedEl.style.width = "".concat(newRect.width, "px");
-    }
+    draggedEl.style.height = "".concat(newRect.height, "px");
+    draggedEl.style.width = "".concat(newRect.width, "px");
     draggedEl.style.left = "".concat(parseFloat(draggedEl.style.left) - relativeDistanceOfMousePointerFromDraggedSides.left * widthChange, "px");
     draggedEl.style.top = "".concat(parseFloat(draggedEl.style.top) - relativeDistanceOfMousePointerFromDraggedSides.top * heightChange, "px");
   }
@@ -1230,9 +1070,7 @@ function morphDraggedElementToBeLike(draggedEl, copyFromEl, currentMouseX, curre
 function copyStylesFromTo(copyFromEl, copyToEl) {
   var computedStyle = window.getComputedStyle(copyFromEl);
   Array.from(computedStyle).filter(function (s) {
-    return s.startsWith("background") || s.startsWith("padding") || s.startsWith("font") || s.startsWith("text") || s.startsWith("align") || s.startsWith("justify") || s.startsWith("display") || s.startsWith("flex") || s.startsWith("border") || s === "opacity" || s === "color" || s === "list-style-type" ||
-    // copying with and height to make up for rect update timing issues in some browsers
-    getFeatureFlag(FEATURE_FLAG_NAMES.USE_COMPUTED_STYLE_INSTEAD_OF_BOUNDING_RECT) && (s === "width" || s === "height");
+    return s.startsWith("background") || s.startsWith("padding") || s.startsWith("font") || s.startsWith("text") || s.startsWith("align") || s.startsWith("justify") || s.startsWith("display") || s.startsWith("flex") || s.startsWith("border") || s === "opacity" || s === "color" || s === "list-style-type";
   }).forEach(function (s) {
     return copyToEl.style.setProperty(s, computedStyle.getPropertyValue(s), computedStyle.getPropertyPriority(s));
   });
@@ -1349,13 +1187,10 @@ function preventShrinking(el) {
 
 var DEFAULT_DROP_ZONE_TYPE$1 = "--any--";
 var MIN_OBSERVATION_INTERVAL_MS = 100;
-var DISABLED_OBSERVATION_INTERVAL_MS = 20;
 var MIN_MOVEMENT_BEFORE_DRAG_START_PX = 3;
-var DEFAULT_TOUCH_DELAY_MS = 80;
 var DEFAULT_DROP_TARGET_STYLE$1 = {
   outline: "rgba(255, 255, 102, 0.7) solid 2px"
 };
-var ORIGINAL_DRAGGED_ITEM_MARKER_ATTRIBUTE = "data-is-dnd-original-dragged-item";
 var originalDragTarget;
 var draggedEl;
 var draggedElData;
@@ -1371,9 +1206,6 @@ var finalizingPreviousDrag = false;
 var unlockOriginDzMinDimensions;
 var isDraggedOutsideOfAnyDz = false;
 var scheduledForRemovalAfterDrop = [];
-var multiScroller;
-var touchDragHoldTimer;
-var touchHoldElapsed = false;
 
 // a map from type to a set of drop-zones
 var typeToDropZones$1 = new Map();
@@ -1408,6 +1240,7 @@ function watchDraggedElement() {
   printDebug(function () {
     return "watching dragged element";
   });
+  armWindowScroller();
   var dropZones = typeToDropZones$1.get(draggedElType);
   var _iterator = _createForOfIteratorHelper(dropZones),
     _step;
@@ -1424,21 +1257,17 @@ function watchDraggedElement() {
     _iterator.f();
   }
   window.addEventListener(DRAGGED_LEFT_DOCUMENT_EVENT_NAME, handleDrop$1);
-
   // it is important that we don't have an interval that is faster than the flip duration because it can cause elements to jump bach and forth
-  var setIntervalMs = Math.max.apply(Math, _toConsumableArray(Array.from(dropZones.keys()).map(function (dz) {
+  var observationIntervalMs = Math.max.apply(Math, [MIN_OBSERVATION_INTERVAL_MS].concat(_toConsumableArray(Array.from(dropZones.keys()).map(function (dz) {
     return dzToConfig$1.get(dz).dropAnimationDurationMs;
-  })));
-  var observationIntervalMs = setIntervalMs === 0 ? DISABLED_OBSERVATION_INTERVAL_MS : Math.max(setIntervalMs, MIN_OBSERVATION_INTERVAL_MS); // if setIntervalMs is 0 it goes to 20, otherwise it is max between it and min observation.
-  multiScroller = createMultiScroller(dropZones, function () {
-    return currentMousePosition;
-  });
-  observe(draggedEl, dropZones, observationIntervalMs * 1.07, multiScroller);
+  }))));
+  observe(draggedEl, dropZones, observationIntervalMs * 1.07);
 }
 function unWatchDraggedElement() {
   printDebug(function () {
     return "unwatching dragged element";
   });
+  disarmWindowScroller();
   var dropZones = typeToDropZones$1.get(draggedElType);
   var _iterator2 = _createForOfIteratorHelper(dropZones),
     _step2;
@@ -1455,21 +1284,20 @@ function unWatchDraggedElement() {
     _iterator2.f();
   }
   window.removeEventListener(DRAGGED_LEFT_DOCUMENT_EVENT_NAME, handleDrop$1);
-  // ensuring multiScroller is not already destroyed before destroying
-  if (multiScroller) {
-    multiScroller.destroy();
-    multiScroller = undefined;
-  }
   unobserve();
 }
-function findShadowElementIdx(items) {
+
+// finds the initial placeholder that is placed there on drag start
+function findShadowPlaceHolderIdx(items) {
   return items.findIndex(function (item) {
-    return !!item[SHADOW_ITEM_MARKER_PROPERTY_NAME];
+    return item[ITEM_ID_KEY] === SHADOW_PLACEHOLDER_ITEM_ID;
   });
 }
-function createShadowElData(draggedElData) {
-  var _objectSpread2$1;
-  return _objectSpread2(_objectSpread2({}, draggedElData), {}, (_objectSpread2$1 = {}, _defineProperty(_objectSpread2$1, SHADOW_ITEM_MARKER_PROPERTY_NAME, true), _defineProperty(_objectSpread2$1, ITEM_ID_KEY, SHADOW_PLACEHOLDER_ITEM_ID), _objectSpread2$1));
+function findShadowElementIdx(items) {
+  // checking that the id is not the placeholder's for Dragula like usecases
+  return items.findIndex(function (item) {
+    return !!item[SHADOW_ITEM_MARKER_PROPERTY_NAME] && item[ITEM_ID_KEY] !== SHADOW_PLACEHOLDER_ITEM_ID;
+  });
 }
 
 /* custom drag-events handlers */
@@ -1504,8 +1332,20 @@ function handleDraggedEntered(e) {
       id: draggedElData[ITEM_ID_KEY],
       source: SOURCES.POINTER
     });
+  } else {
+    var shadowPlaceHolderIdx = findShadowPlaceHolderIdx(items);
+    if (shadowPlaceHolderIdx !== -1) {
+      // only happens right after drag start, on the first drag entered event
+      printDebug(function () {
+        return "removing placeholder item from origin dz";
+      });
+      items.splice(shadowPlaceHolderIdx, 1);
+    }
   }
-  var shadowElIdx = e.detail.indexObj.index;
+  var _e$detail$indexObj = e.detail.indexObj,
+    index = _e$detail$indexObj.index,
+    isProximityBased = _e$detail$indexObj.isProximityBased;
+  var shadowElIdx = isProximityBased && index === e.currentTarget.children.length - 1 ? index + 1 : index;
   shadowElDropZone = e.currentTarget;
   items.splice(shadowElIdx, 0, shadowElData);
   dispatchConsiderEvent(e.currentTarget, items, {
@@ -1521,7 +1361,7 @@ function handleDraggedLeft(e) {
     return ["dragged left", e.currentTarget, e.detail];
   });
   var _dzToConfig$get2 = dzToConfig$1.get(e.currentTarget),
-    originalItems = _dzToConfig$get2.items,
+    items = _dzToConfig$get2.items,
     dropFromOthersDisabled = _dzToConfig$get2.dropFromOthersDisabled;
   if (dropFromOthersDisabled && e.currentTarget !== originDropZone && e.currentTarget !== shadowElDropZone) {
     printDebug(function () {
@@ -1529,12 +1369,8 @@ function handleDraggedLeft(e) {
     });
     return;
   }
-  var items = _toConsumableArray(originalItems);
   var shadowElIdx = findShadowElementIdx(items);
-  if (shadowElIdx !== -1) {
-    items.splice(shadowElIdx, 1);
-  }
-  var origShadowDz = shadowElDropZone;
+  var shadowItem = items.splice(shadowElIdx, 1)[0];
   shadowElDropZone = undefined;
   var _e$detail = e.detail,
     type = _e$detail.type,
@@ -1545,9 +1381,8 @@ function handleDraggedLeft(e) {
     });
     isDraggedOutsideOfAnyDz = true;
     shadowElDropZone = originDropZone;
-    // if the last zone it left is the origin dz, we will put it back into items (which we just removed it from)
-    var originZoneItems = origShadowDz === originDropZone ? items : _toConsumableArray(dzToConfig$1.get(originDropZone).items);
-    originZoneItems.splice(originIndex, 0, shadowElData);
+    var originZoneItems = dzToConfig$1.get(originDropZone).items;
+    originZoneItems.splice(originIndex, 0, shadowItem);
     dispatchConsiderEvent(originDropZone, originZoneItems, {
       trigger: TRIGGERS.DRAGGED_LEFT_ALL,
       id: draggedElData[ITEM_ID_KEY],
@@ -1566,7 +1401,7 @@ function handleDraggedIsOverIndex(e) {
     return ["dragged is over index", e.currentTarget, e.detail];
   });
   var _dzToConfig$get3 = dzToConfig$1.get(e.currentTarget),
-    originalItems = _dzToConfig$get3.items,
+    items = _dzToConfig$get3.items,
     dropFromOthersDisabled = _dzToConfig$get3.dropFromOthersDisabled;
   if (dropFromOthersDisabled && e.currentTarget !== originDropZone) {
     printDebug(function () {
@@ -1574,13 +1409,10 @@ function handleDraggedIsOverIndex(e) {
     });
     return;
   }
-  var items = _toConsumableArray(originalItems);
   isDraggedOutsideOfAnyDz = false;
   var index = e.detail.indexObj.index;
   var shadowElIdx = findShadowElementIdx(items);
-  if (shadowElIdx !== -1) {
-    items.splice(shadowElIdx, 1);
-  }
+  items.splice(shadowElIdx, 1);
   items.splice(index, 0, shadowElData);
   dispatchConsiderEvent(e.currentTarget, items, {
     trigger: TRIGGERS.DRAGGED_OVER_INDEX,
@@ -1593,9 +1425,12 @@ function handleDraggedIsOverIndex(e) {
 function handleMouseMove(e) {
   e.preventDefault();
   var c = e.touches ? e.touches[0] : e;
+  var _dzToConfig$get4 = dzToConfig$1.get(originDropZone),
+    constrainAxisX = _dzToConfig$get4.constrainAxisX,
+    constrainAxisY = _dzToConfig$get4.constrainAxisY;
   currentMousePosition = {
-    x: c.clientX,
-    y: c.clientY
+    x: constrainAxisX ? dragStartMousePosition.x : c.clientX,
+    y: constrainAxisY ? dragStartMousePosition.y : c.clientY
   };
   draggedEl.style.transform = "translate3d(".concat(currentMousePosition.x - dragStartMousePosition.x, "px, ").concat(currentMousePosition.y - dragStartMousePosition.y, "px, 0)");
 }
@@ -1620,9 +1455,9 @@ function handleDrop$1() {
   printDebug(function () {
     return ["dropped in dz", shadowElDropZone];
   });
-  var _dzToConfig$get4 = dzToConfig$1.get(shadowElDropZone),
-    items = _dzToConfig$get4.items,
-    type = _dzToConfig$get4.type;
+  var _dzToConfig$get5 = dzToConfig$1.get(shadowElDropZone),
+    items = _dzToConfig$get5.items,
+    type = _dzToConfig$get5.type;
   styleInactiveDropZones(typeToDropZones$1.get(type), function (dz) {
     return dzToConfig$1.get(dz).dropTargetStyle;
   }, function (dz) {
@@ -1630,11 +1465,7 @@ function handleDrop$1() {
   });
   var shadowElIdx = findShadowElementIdx(items);
   // the handler might remove the shadow element, ex: dragula like copy on drag
-  if (shadowElIdx === -1) {
-    if (shadowElDropZone === originDropZone) {
-      shadowElIdx = originIndex;
-    }
-  }
+  if (shadowElIdx === -1) shadowElIdx = originIndex;
   items = items.map(function (item) {
     return item[SHADOW_ITEM_MARKER_PROPERTY_NAME] ? draggedElData : item;
   });
@@ -1653,29 +1484,21 @@ function handleDrop$1() {
         source: SOURCES.POINTER
       });
     }
-    // In edge cases the dom might have not been updated yet so we can't rely on data list index
-    var domShadowEl = Array.from(shadowElDropZone.children).find(function (c) {
-      return c.getAttribute(SHADOW_ELEMENT_ATTRIBUTE_NAME);
-    });
-    if (domShadowEl) unDecorateShadowElement(domShadowEl);
+    unDecorateShadowElement(shadowElDropZone.children[shadowElIdx]);
     cleanupPostDrop();
   }
-  if (dzToConfig$1.get(shadowElDropZone).dropAnimationDisabled) {
-    finalizeWithinZone();
-  } else {
-    animateDraggedToFinalPosition(shadowElIdx, finalizeWithinZone);
-  }
+  animateDraggedToFinalPosition(shadowElIdx, finalizeWithinZone);
 }
 
 // helper function for handleDrop
 function animateDraggedToFinalPosition(shadowElIdx, callback) {
-  var shadowElRect = shadowElIdx > -1 ? getBoundingRectNoTransforms(shadowElDropZone.children[shadowElIdx], false) : getBoundingRectNoTransforms(shadowElDropZone, false);
+  var shadowElRect = getBoundingRectNoTransforms(shadowElDropZone.children[shadowElIdx]);
   var newTransform = {
     x: shadowElRect.left - parseFloat(draggedEl.style.left),
     y: shadowElRect.top - parseFloat(draggedEl.style.top)
   };
-  var _dzToConfig$get5 = dzToConfig$1.get(shadowElDropZone),
-    dropAnimationDurationMs = _dzToConfig$get5.dropAnimationDurationMs;
+  var _dzToConfig$get6 = dzToConfig$1.get(shadowElDropZone),
+    dropAnimationDurationMs = _dzToConfig$get6.dropAnimationDurationMs;
   var transition = "transform ".concat(dropAnimationDurationMs, "ms ease");
   draggedEl.style.transition = draggedEl.style.transition ? draggedEl.style.transition + "," + transition : transition;
   draggedEl.style.transform = "translate3d(".concat(newTransform.x, "px, ").concat(newTransform.y, "px, 0)");
@@ -1693,12 +1516,19 @@ function scheduleDZForRemovalAfterDrop(dz, destroy) {
 }
 /* cleanup */
 function cleanupPostDrop() {
-  // Remove the temporary elements that were kept in the DOM during the drag
-  if (draggedEl && draggedEl.remove) {
-    draggedEl.remove();
-  }
-  if (originalDragTarget && originalDragTarget.remove) {
-    originalDragTarget.remove();
+  draggedEl.remove();
+  originalDragTarget.remove();
+  if (scheduledForRemovalAfterDrop.length) {
+    printDebug(function () {
+      return ["will destroy zones that were removed during drag", scheduledForRemovalAfterDrop];
+    });
+    scheduledForRemovalAfterDrop.forEach(function (_ref) {
+      var dz = _ref.dz,
+        destroy = _ref.destroy;
+      destroy();
+      dz.remove();
+    });
+    scheduledForRemovalAfterDrop = [];
   }
   draggedEl = undefined;
   originalDragTarget = undefined;
@@ -1714,23 +1544,6 @@ function cleanupPostDrop() {
   finalizingPreviousDrag = false;
   unlockOriginDzMinDimensions = undefined;
   isDraggedOutsideOfAnyDz = false;
-  if (touchDragHoldTimer) {
-    clearTimeout(touchDragHoldTimer);
-  }
-  touchDragHoldTimer = undefined;
-  touchHoldElapsed = false;
-  if (scheduledForRemovalAfterDrop.length) {
-    printDebug(function () {
-      return ["will destroy zones that were removed during drag", scheduledForRemovalAfterDrop];
-    });
-    scheduledForRemovalAfterDrop.forEach(function (_ref) {
-      var dz = _ref.dz,
-        destroy = _ref.destroy;
-      destroy();
-      dz.remove();
-    });
-    scheduledForRemovalAfterDrop = [];
-  }
 }
 function dndzone$2(node, options) {
   var initialized = false;
@@ -1738,15 +1551,15 @@ function dndzone$2(node, options) {
     items: undefined,
     type: undefined,
     flipDurationMs: 0,
+    constrainAxisX: false,
+    constrainAxisY: false,
     dragDisabled: false,
     morphDisabled: false,
     dropFromOthersDisabled: false,
     dropTargetStyle: DEFAULT_DROP_TARGET_STYLE$1,
     dropTargetClasses: [],
     transformDraggedElement: function transformDraggedElement() {},
-    centreDraggedOnCursor: false,
-    dropAnimationDisabled: false,
-    delayTouchStartMs: 0
+    centreDraggedOnCursor: false
   };
   printDebug(function () {
     return ["dndzone good to go options: ".concat(toString(options), ", config: ").concat(toString(config)), {
@@ -1774,52 +1587,16 @@ function dndzone$2(node, options) {
     window.removeEventListener("touchmove", handleMouseMoveMaybeDragStart);
     window.removeEventListener("mouseup", handleFalseAlarm);
     window.removeEventListener("touchend", handleFalseAlarm);
-    if (touchDragHoldTimer) {
-      clearTimeout(touchDragHoldTimer);
-      touchDragHoldTimer = undefined;
-      touchHoldElapsed = false;
-    }
   }
-  function handleFalseAlarm(e) {
+  function handleFalseAlarm() {
     removeMaybeListeners();
     originalDragTarget = undefined;
     dragStartMousePosition = undefined;
     currentMousePosition = undefined;
-
-    // dragging initiated by touch events prevents onclick from initially firing
-    if (e.type === "touchend") {
-      var clickEvent = new Event("click", {
-        bubbles: true,
-        cancelable: true
-      });
-      // doing it this way instead of calling .click() because that doesn't work for SVG elements
-      e.target.dispatchEvent(clickEvent);
-    }
   }
   function handleMouseMoveMaybeDragStart(e) {
-    var isTouch = !!e.touches;
-    var c = isTouch ? e.touches[0] : e;
-    // If touch drag delay is configured and not elapsed yet, allow scrolling until either
-    // the delay elapses (timer will call handleDragStart) or the user moves significantly,
-    // in which case we cancel the potential drag and let the interaction be a scroll.
-    if (isTouch && config.delayTouchStartMs > 0 && !touchHoldElapsed) {
-      currentMousePosition = {
-        x: c.clientX,
-        y: c.clientY
-      };
-      if (Math.abs(currentMousePosition.x - dragStartMousePosition.x) >= MIN_MOVEMENT_BEFORE_DRAG_START_PX || Math.abs(currentMousePosition.y - dragStartMousePosition.y) >= MIN_MOVEMENT_BEFORE_DRAG_START_PX) {
-        // User started scrolling, cancel drag attempt.
-        if (touchDragHoldTimer) {
-          clearTimeout(touchDragHoldTimer);
-          touchDragHoldTimer = undefined;
-        }
-        handleFalseAlarm(e);
-      }
-      return; // Do not preventDefault so scrolling works.
-    }
-
-    // legacy / post-delay path – block scrolling and maybe start drag
     e.preventDefault();
+    var c = e.touches ? e.touches[0] : e;
     currentMousePosition = {
       x: c.clientX,
       y: c.clientY
@@ -1850,29 +1627,14 @@ function dndzone$2(node, options) {
       });
       return;
     }
-    var isTouchStart = !!e.touches;
-    var useDelay = isTouchStart && config.delayTouchStartMs > 0;
-    if (!useDelay) {
-      e.preventDefault();
-    }
     e.stopPropagation();
-    var c = isTouchStart ? e.touches[0] : e;
+    var c = e.touches ? e.touches[0] : e;
     dragStartMousePosition = {
       x: c.clientX,
       y: c.clientY
     };
     currentMousePosition = _objectSpread2({}, dragStartMousePosition);
     originalDragTarget = e.currentTarget;
-    if (useDelay) {
-      touchHoldElapsed = false;
-      touchDragHoldTimer = window.setTimeout(function () {
-        // If the finger is still down and no false-alarm happened
-        if (!originalDragTarget) return;
-        touchHoldElapsed = true;
-        removeMaybeListeners();
-        handleDragStart();
-      }, config.delayTouchStartMs);
-    }
     addMaybeListeners();
   }
   function handleDragStart() {
@@ -1885,32 +1647,29 @@ function dndzone$2(node, options) {
     var currentIdx = elToIdx.get(originalDragTarget);
     originIndex = currentIdx;
     originDropZone = originalDragTarget.parentElement;
-    /** @type {ShadowRoot | HTMLDocument | Element } */
-    var rootNode = originDropZone.closest("dialog") || originDropZone.closest("[popover]") || originDropZone.getRootNode();
+    /** @type {ShadowRoot | HTMLDocument} */
+    var rootNode = originDropZone.getRootNode();
     var originDropZoneRoot = rootNode.body || rootNode;
-    var originalItems = config.items,
+    var items = config.items,
       type = config.type,
       centreDraggedOnCursor = config.centreDraggedOnCursor;
-    var items = _toConsumableArray(originalItems);
-    draggedElData = items[currentIdx];
+    draggedElData = _objectSpread2({}, items[currentIdx]);
     draggedElType = type;
-    shadowElData = createShadowElData(draggedElData);
+    shadowElData = _objectSpread2(_objectSpread2({}, draggedElData), {}, _defineProperty({}, SHADOW_ITEM_MARKER_PROPERTY_NAME, true));
+    // The initial shadow element. We need a different id at first in order to avoid conflicts and timing issues
+    var placeHolderElData = _objectSpread2(_objectSpread2({}, shadowElData), {}, _defineProperty({}, ITEM_ID_KEY, SHADOW_PLACEHOLDER_ITEM_ID));
 
     // creating the draggable element
     draggedEl = createDraggedElementFrom(originalDragTarget, centreDraggedOnCursor && currentMousePosition);
-    originDropZoneRoot.appendChild(draggedEl);
     // We will keep the original dom node in the dom because touch events keep firing on it, we want to re-add it after the framework removes it
     function keepOriginalElementInDom() {
-      if (!originalDragTarget.parentElement) {
-        originalDragTarget.setAttribute(ORIGINAL_DRAGGED_ITEM_MARKER_ATTRIBUTE, true);
-        originDropZoneRoot.appendChild(originalDragTarget);
-        // have to watch before we hide, otherwise Svelte 5 $state gets confused
-        watchDraggedElement();
-        hideElement(originalDragTarget);
-        // after the removal of the original element we can give the shadow element the original item id so that the host zone can find it and render it correctly if it does lookups by id
-        shadowElData[ITEM_ID_KEY] = draggedElData[ITEM_ID_KEY];
+      if (!draggedEl.parentElement) {
+        originDropZoneRoot.appendChild(draggedEl);
         // to prevent the outline from disappearing
         draggedEl.focus();
+        watchDraggedElement();
+        hideElement(originalDragTarget);
+        originDropZoneRoot.appendChild(originalDragTarget);
       } else {
         window.requestAnimationFrame(keepOriginalElementInDom);
       }
@@ -1925,7 +1684,7 @@ function dndzone$2(node, options) {
     });
 
     // removing the original element by removing its data entry
-    items.splice(currentIdx, 1, shadowElData);
+    items.splice(currentIdx, 1, placeHolderElData);
     unlockOriginDzMinDimensions = preventShrinking(originDropZone);
     dispatchConsiderEvent(originDropZone, items, {
       trigger: TRIGGERS.DRAG_STARTED,
@@ -1955,6 +1714,10 @@ function dndzone$2(node, options) {
       dropAnimationDurationMs = _ref2$flipDurationMs === void 0 ? 0 : _ref2$flipDurationMs,
       _ref2$type = _ref2.type,
       newType = _ref2$type === void 0 ? DEFAULT_DROP_ZONE_TYPE$1 : _ref2$type,
+      _ref2$constrainAxisX = _ref2.constrainAxisX,
+      constrainAxisX = _ref2$constrainAxisX === void 0 ? false : _ref2$constrainAxisX,
+      _ref2$constrainAxisY = _ref2.constrainAxisY,
+      constrainAxisY = _ref2$constrainAxisY === void 0 ? false : _ref2$constrainAxisY,
       _ref2$dragDisabled = _ref2.dragDisabled,
       dragDisabled = _ref2$dragDisabled === void 0 ? false : _ref2$dragDisabled,
       _ref2$morphDisabled = _ref2.morphDisabled,
@@ -1968,29 +1731,20 @@ function dndzone$2(node, options) {
       _ref2$transformDragge = _ref2.transformDraggedElement,
       transformDraggedElement = _ref2$transformDragge === void 0 ? function () {} : _ref2$transformDragge,
       _ref2$centreDraggedOn = _ref2.centreDraggedOnCursor,
-      centreDraggedOnCursor = _ref2$centreDraggedOn === void 0 ? false : _ref2$centreDraggedOn,
-      _ref2$dropAnimationDi = _ref2.dropAnimationDisabled,
-      dropAnimationDisabled = _ref2$dropAnimationDi === void 0 ? false : _ref2$dropAnimationDi,
-      _ref2$delayTouchStart = _ref2.delayTouchStart,
-      delayTouchStartOpt = _ref2$delayTouchStart === void 0 ? false : _ref2$delayTouchStart;
+      centreDraggedOnCursor = _ref2$centreDraggedOn === void 0 ? false : _ref2$centreDraggedOn;
     config.dropAnimationDurationMs = dropAnimationDurationMs;
-    var effectiveDelayMs = 0;
-    if (delayTouchStartOpt === true) {
-      effectiveDelayMs = DEFAULT_TOUCH_DELAY_MS;
-    } else if (typeof delayTouchStartOpt === "number" && isFinite(delayTouchStartOpt) && delayTouchStartOpt >= 0) {
-      effectiveDelayMs = delayTouchStartOpt;
-    }
-    config.delayTouchStartMs = effectiveDelayMs;
     if (config.type && newType !== config.type) {
       unregisterDropZone$1(node, config.type);
     }
     config.type = newType;
+    registerDropZone$1(node, newType);
     config.items = _toConsumableArray(items);
+    config.constrainAxisX = constrainAxisX;
+    config.constrainAxisY = constrainAxisY;
     config.dragDisabled = dragDisabled;
     config.morphDisabled = morphDisabled;
     config.transformDraggedElement = transformDraggedElement;
     config.centreDraggedOnCursor = centreDraggedOnCursor;
-    config.dropAnimationDisabled = dropAnimationDisabled;
 
     // realtime update for dropTargetStyle
     if (initialized && isWorkingOnPreviousDrag && !finalizingPreviousDrag && (!areObjectsShallowEqual(dropTargetStyle, config.dropTargetStyle) || !areArraysShallowEqualSameOrder(dropTargetClasses, config.dropTargetClasses))) {
@@ -2029,16 +1783,15 @@ function dndzone$2(node, options) {
     }
     config.dropFromOthersDisabled = dropFromOthersDisabled;
     dzToConfig$1.set(node, config);
-    registerDropZone$1(node, newType);
-    var shadowElIdx = isWorkingOnPreviousDrag ? findShadowElementIdx(config.items) : -1;
+    var shadowElIdx = findShadowElementIdx(config.items);
     for (var idx = 0; idx < node.children.length; idx++) {
       var draggableEl = node.children[idx];
       styleDraggable(draggableEl, dragDisabled);
       if (idx === shadowElIdx) {
+        config.transformDraggedElement(draggedEl, draggedElData, idx);
         if (!morphDisabled) {
           morphDraggedElementToBeLike(draggedEl, draggableEl, currentMousePosition.x, currentMousePosition.y);
         }
-        config.transformDraggedElement(draggedEl, draggedElData, idx);
         decorateShadowEl(draggableEl);
         continue;
       }
@@ -2072,7 +1825,7 @@ function dndzone$2(node, options) {
         unregisterDropZone$1(node, dzToConfig$1.get(node).type);
         dzToConfig$1["delete"](node);
       }
-      if (isWorkingOnPreviousDrag && !node.closest("[".concat(ORIGINAL_DRAGGED_ITEM_MARKER_ATTRIBUTE, "]"))) {
+      if (isWorkingOnPreviousDrag) {
         printDebug(function () {
           return "pointer dndzone will be scheduled for destruction";
         });
@@ -2350,7 +2103,6 @@ function dndzone$1(node, options) {
     type: undefined,
     dragDisabled: false,
     zoneTabIndex: 0,
-    zoneItemTabIndex: 0,
     dropFromOthersDisabled: false,
     dropTargetStyle: DEFAULT_DROP_TARGET_STYLE,
     dropTargetClasses: [],
@@ -2480,7 +2232,7 @@ function dndzone$1(node, options) {
     var children = Array.from(node.children);
     var focusedItemIdx = children.indexOf(draggableEl);
     focusedItem = draggableEl;
-    focusedItem.tabIndex = config.zoneItemTabIndex;
+    focusedItem.tabIndex = 0;
     focusedItemId = items[focusedItemIdx][ITEM_ID_KEY];
     focusedItemLabel = children[focusedItemIdx].getAttribute("aria-label") || "";
   }
@@ -2493,8 +2245,6 @@ function dndzone$1(node, options) {
       dragDisabled = _ref2$dragDisabled === void 0 ? false : _ref2$dragDisabled,
       _ref2$zoneTabIndex = _ref2.zoneTabIndex,
       zoneTabIndex = _ref2$zoneTabIndex === void 0 ? 0 : _ref2$zoneTabIndex,
-      _ref2$zoneItemTabInde = _ref2.zoneItemTabIndex,
-      zoneItemTabIndex = _ref2$zoneItemTabInde === void 0 ? 0 : _ref2$zoneItemTabInde,
       _ref2$dropFromOthersD = _ref2.dropFromOthersDisabled,
       dropFromOthersDisabled = _ref2$dropFromOthersD === void 0 ? false : _ref2$dropFromOthersD,
       _ref2$dropTargetStyle = _ref2.dropTargetStyle,
@@ -2507,7 +2257,6 @@ function dndzone$1(node, options) {
     config.dragDisabled = dragDisabled;
     config.dropFromOthersDisabled = dropFromOthersDisabled;
     config.zoneTabIndex = zoneTabIndex;
-    config.zoneItemTabIndex = zoneItemTabIndex;
     config.dropTargetStyle = dropTargetStyle;
     config.dropTargetClasses = dropTargetClasses;
     config.autoAriaDisabled = autoAriaDisabled;
@@ -2531,7 +2280,7 @@ function dndzone$1(node, options) {
     var _loop = function _loop(i) {
       var draggableEl = node.children[i];
       allDragTargets.add(draggableEl);
-      draggableEl.tabIndex = isDragging ? -1 : config.zoneItemTabIndex;
+      draggableEl.tabIndex = isDragging ? -1 : 0;
       if (!autoAriaDisabled) {
         draggableEl.setAttribute("role", "listitem");
       }
@@ -2552,7 +2301,7 @@ function dndzone$1(node, options) {
         });
         // if it is a nested dropzone, it was re-rendered and we need to refresh our pointer
         focusedItem = draggableEl;
-        focusedItem.tabIndex = config.zoneItemTabIndex;
+        focusedItem.tabIndex = 0;
         // without this the element loses focus if it moves backwards in the list
         draggableEl.focus();
       }
@@ -2582,7 +2331,7 @@ function dndzone$1(node, options) {
   return handles;
 }
 
-var _excluded = ["items", "flipDurationMs", "type", "dragDisabled", "morphDisabled", "dropFromOthersDisabled", "zoneTabIndex", "zoneItemTabIndex", "dropTargetStyle", "dropTargetClasses", "transformDraggedElement", "autoAriaDisabled", "centreDraggedOnCursor", "delayTouchStart", "dropAnimationDisabled"];
+var _excluded = ["items", "flipDurationMs", "type", "constrainAxisX", "constrainAxisY", "dragDisabled", "morphDisabled", "dropFromOthersDisabled", "zoneTabIndex", "dropTargetStyle", "dropTargetClasses", "transformDraggedElement", "autoAriaDisabled", "centreDraggedOnCursor"];
 
 /**
  * A custom action to turn any container to a dnd zone and all of its direct children to draggables
@@ -2594,28 +2343,20 @@ var _excluded = ["items", "flipDurationMs", "type", "dragDisabled", "morphDisabl
  * @property {array} items - the list of items that was used to generate the children of the given node (the list used in the #each block
  * @property {string} [type] - the type of the dnd zone. children dragged from here can only be dropped in other zones of the same type, default to a base type
  * @property {number} [flipDurationMs] - if the list animated using flip (recommended), specifies the flip duration such that everything syncs with it without conflict, defaults to zero
+ * @property {boolean} [constrainAxisX] - Constrain dragging by X axis. Drag will be allowed only by Y axis.
+ * @property {boolean} [constrainAxisY] - Constrain dragging by Y axis. Drag will be allowed only by X axis.
  * @property {boolean} [dragDisabled]
  * @property {boolean} [morphDisabled] - whether dragged element should morph to zone dimensions
  * @property {boolean} [dropFromOthersDisabled]
  * @property {number} [zoneTabIndex] - set the tabindex of the list container when not dragging
- * @property {number} [zoneItemTabIndex] - set the tabindex of the list container items when not dragging
  * @property {object} [dropTargetStyle]
  * @property {string[]} [dropTargetClasses]
- * @property {boolean|number} [delayTouchStart] - On touch devices, wait this long before converting the gesture to a drag.
- * `true` uses the built-in default (80 ms).
- * @property {boolean} [dropAnimationDisabled] - cancels the drop animation to place
  * @property {function} [transformDraggedElement]
  * @param {HTMLElement} node - the element to enhance
  * @param {Options} options
  * @return {{update: function, destroy: function}}
  */
 function dndzone(node, options) {
-  if (shouldIgnoreZone(node)) {
-    return {
-      update: function update() {},
-      destroy: function destroy() {}
-    };
-  }
   validateOptions(options);
   var pointerZone = dndzone$2(node, options);
   var keyboardZone = dndzone$1(node, options);
@@ -2631,33 +2372,22 @@ function dndzone(node, options) {
     }
   };
 }
-
-/**
- * If the user marked something in the ancestry of our node as shadow element, we can ignore it
- * We need the user to mark it for us because svelte updates the action from deep to shallow (but renders top down)
- * @param {HTMLElement} node
- * @return {boolean}
- */
-function shouldIgnoreZone(node) {
-  return !!node.closest("[".concat(SHADOW_ELEMENT_HINT_ATTRIBUTE_NAME, "=\"true\"]"));
-}
 function validateOptions(options) {
   /*eslint-disable*/
   var items = options.items;
     options.flipDurationMs;
     options.type;
+    options.constrainAxisX;
+    options.constrainAxisY;
     options.dragDisabled;
     options.morphDisabled;
     options.dropFromOthersDisabled;
-    var zoneTabIndex = options.zoneTabIndex,
-    zoneItemTabIndex = options.zoneItemTabIndex;
+    var zoneTabIndex = options.zoneTabIndex;
     options.dropTargetStyle;
     var dropTargetClasses = options.dropTargetClasses;
     options.transformDraggedElement;
     options.autoAriaDisabled;
     options.centreDraggedOnCursor;
-    var delayTouchStart = options.delayTouchStart;
-    options.dropAnimationDisabled;
     var rest = _objectWithoutProperties(options, _excluded);
   /*eslint-enable*/
   if (Object.keys(rest).length > 0) {
@@ -2678,16 +2408,6 @@ function validateOptions(options) {
   if (zoneTabIndex && !isInt(zoneTabIndex)) {
     throw new Error("zoneTabIndex should be a number but instead it is a ".concat(_typeof(zoneTabIndex), ", ").concat(toString(zoneTabIndex)));
   }
-  if (zoneItemTabIndex && !isInt(zoneItemTabIndex)) {
-    throw new Error("zoneItemTabIndex should be a number but instead it is a ".concat(_typeof(zoneItemTabIndex), ", ").concat(toString(zoneItemTabIndex)));
-  }
-  if (delayTouchStart !== undefined && delayTouchStart !== false) {
-    var validBoolean = delayTouchStart === true;
-    var validNumber = typeof delayTouchStart === "number" && isFinite(delayTouchStart) && delayTouchStart >= 0;
-    if (!validBoolean && !validNumber) {
-      throw new Error("delayTouchStart should be a boolean (true/false) or a non-negative number but instead it is a ".concat(_typeof(delayTouchStart), ", ").concat(toString(delayTouchStart)));
-    }
-  }
 }
 function isInt(value) {
   return !isNaN(value) && function (x) {
@@ -2695,150 +2415,4 @@ function isInt(value) {
   }(parseFloat(value));
 }
 
-function createStore(initialValue) {
-  var _val = initialValue;
-  var subs = new Set();
-  return {
-    get: function get() {
-      return _val;
-    },
-    set: function set(newVal) {
-      _val = newVal;
-      Array.from(subs).forEach(function (cb) {
-        return cb(_val);
-      });
-    },
-    subscribe: function subscribe(cb) {
-      subs.add(cb);
-      cb(_val);
-    },
-    unsubscribe: function unsubscribe(cb) {
-      subs["delete"](cb);
-    }
-  };
-}
-
-var isItemsDragDisabled = createStore(true);
-var userDragDisabled = createStore(false);
-function getAddedOptions() {
-  return {
-    dragDisabled: userDragDisabled.get() || isItemsDragDisabled.get(),
-    zoneItemTabIndex: -1
-  };
-}
-
-/**
- * This is an action that wraps around the dndzone action to make it easy to work with drag handles
- * When using this you must also use the 'dragHandle' action (see below) on an element inside each item within the zone
- * Credit for the idea and initial implementation goes to @gleuch (Greg Leuch) and @geovie (Georg Vienna)
- *
- * @param {HTMLElement} node
- * @param options - will be passed down to the dndzone
- * @return {{update: (newOptions: Object) => {}, destroy: () => {}}}
- */
-function dragHandleZone(node, options) {
-  var _options$dragDisabled;
-  // Initialise stores from initial options
-  userDragDisabled.set((_options$dragDisabled = options === null || options === void 0 ? void 0 : options.dragDisabled) !== null && _options$dragDisabled !== void 0 ? _options$dragDisabled : false);
-  var currentOptions = options;
-  var zone = dndzone(node, _objectSpread2(_objectSpread2({}, currentOptions), getAddedOptions()));
-  function updateZone() {
-    zone.update(_objectSpread2(_objectSpread2({}, currentOptions), getAddedOptions()));
-  }
-
-  // Subscribe to internal store so finishing a drag updates the zone
-  isItemsDragDisabled.subscribe(updateZone);
-
-  // We don't need to subscribe to userDragDisabled here because updates to
-  // it always come through the `update` lifecycle and will call `updateZone`
-  // anyway.
-
-  function consider(e) {
-    var _e$detail$info = e.detail.info,
-      source = _e$detail$info.source,
-      trigger = _e$detail$info.trigger;
-    // Ensure dragging is stopped on drag finish via keyboard
-    if (source === SOURCES.KEYBOARD && trigger === TRIGGERS.DRAG_STOPPED) {
-      isItemsDragDisabled.set(true);
-    }
-  }
-  function finalize(e) {
-    var source = e.detail.info.source;
-    // Ensure dragging is stopped on drag finish via pointer (mouse, touch)
-    if (source === SOURCES.POINTER) {
-      isItemsDragDisabled.set(true);
-    }
-  }
-  node.addEventListener("consider", consider);
-  node.addEventListener("finalize", finalize);
-  return {
-    update: function update(newOptions) {
-      var _currentOptions$dragD, _currentOptions;
-      currentOptions = newOptions;
-      // keep store in sync with external prop
-      userDragDisabled.set((_currentOptions$dragD = (_currentOptions = currentOptions) === null || _currentOptions === void 0 ? void 0 : _currentOptions.dragDisabled) !== null && _currentOptions$dragD !== void 0 ? _currentOptions$dragD : false);
-      updateZone();
-    },
-    destroy: function destroy() {
-      node.removeEventListener("consider", consider);
-      node.removeEventListener("finalize", finalize);
-      isItemsDragDisabled.unsubscribe(updateZone);
-    }
-  };
-}
-
-/**
- * This should be used to mark drag handles inside items that belong to a 'dragHandleZone' (see above)
- * @param {HTMLElement} handle
- * @return {{update: *, destroy: *}}
- */
-function dragHandle(handle) {
-  handle.setAttribute("role", "button");
-  function startDrag(e) {
-    // preventing default to prevent lag on touch devices (because of the browser checking for screen scrolling)
-    e.preventDefault();
-    isItemsDragDisabled.set(false);
-
-    // Reset the startDrag/isItemsDragDisabled if the user releases the mouse/touch without initiating a drag
-    window.addEventListener("mouseup", resetStartDrag);
-    window.addEventListener("touchend", resetStartDrag);
-  }
-  function handleKeyDown(e) {
-    if (e.key === "Enter" || e.key === " ") isItemsDragDisabled.set(false);
-  }
-  function resetStartDrag() {
-    isItemsDragDisabled.set(true);
-    window.removeEventListener("mouseup", resetStartDrag);
-    window.removeEventListener("touchend", resetStartDrag);
-  }
-  var recomputeHandleState = function recomputeHandleState() {
-    var userDisabled = userDragDisabled.get();
-    var internalDisabled = isItemsDragDisabled.get();
-    if (userDisabled) {
-      handle.tabIndex = -1;
-      handle.style.cursor = ""; // default cursor
-    } else {
-      handle.tabIndex = internalDisabled ? 0 : -1;
-      handle.style.cursor = internalDisabled ? "grab" : "grabbing";
-    }
-  };
-
-  // Subscribe to both stores
-  userDragDisabled.subscribe(recomputeHandleState);
-  isItemsDragDisabled.subscribe(recomputeHandleState);
-  handle.addEventListener("mousedown", startDrag);
-  handle.addEventListener("touchstart", startDrag);
-  handle.addEventListener("keydown", handleKeyDown);
-  return {
-    update: function update() {},
-    destroy: function destroy() {
-      handle.removeEventListener("mousedown", startDrag);
-      handle.removeEventListener("touchstart", startDrag);
-      handle.removeEventListener("keydown", handleKeyDown);
-      userDragDisabled.unsubscribe(recomputeHandleState);
-      isItemsDragDisabled.unsubscribe(recomputeHandleState);
-    }
-  };
-}
-
-export { DRAGGED_ELEMENT_ID, FEATURE_FLAG_NAMES, SHADOW_ITEM_MARKER_PROPERTY_NAME, SHADOW_PLACEHOLDER_ITEM_ID, SOURCES, TRIGGERS, alertToScreenReader, dndzone, dragHandle, dragHandleZone, overrideItemIdKeyNameBeforeInitialisingDndZones, setDebugMode, setFeatureFlag };
+export { DRAGGED_ELEMENT_ID, SHADOW_ITEM_MARKER_PROPERTY_NAME, SHADOW_PLACEHOLDER_ITEM_ID, SOURCES, TRIGGERS, alertToScreenReader, dndzone, overrideItemIdKeyNameBeforeInitialisingDndZones, setDebugMode };
