// scripts/generate-components-typedefs.ts
// Generates src/components.d.ts with global component typings.
// Run with: bun run ./scripts/generate-components-typedefs.ts
// (If you use --watch, Bun will rerun this whenever files change.)

import { promises as fs } from 'node:fs';
import * as path from 'node:path';

const SRC_DIR = path.resolve(process.cwd(), 'src');
const COMPONENTS_DIR = path.join(SRC_DIR, 'components');
const OUTPUT_PATH = path.join(SRC_DIR, 'components.d.ts');

type FileEntry = {
  name: string; // PascalCase name (global const)
  importPath: string; // "./components/....svelte" (posix)
  absPath: string; // absolute path
};

export async function generateComponentsTypedefs() {
  // Ensure components dir exists
  const exists = await dirExists(COMPONENTS_DIR);
  if (!exists) {
    console.error(`[generate-components-typedefs] Directory not found: ${COMPONENTS_DIR}`);
    process.exit(1);
  }

  const svelteFiles = await collectSvelteFiles(COMPONENTS_DIR);

  const entries: FileEntry[] = svelteFiles.map((abs) => {
    // Create a posix-style relative path from src to the file, prefixed with "./"
    const relFromSrc = path.posix.join(
      ...path.relative(SRC_DIR, abs).split(path.sep) // convert to posix segments
    );
    const importPath = `./${relFromSrc}`;

    const fileBase = path.basename(abs, '.svelte');
    const name = toPascalCase(fileBase);

    return { name, importPath, absPath: abs };
  });

  // Deduplicate by name (warn if duplicates)
  const deduped = new Map<string, FileEntry>();
  for (const e of entries) {
    if (deduped.has(e.name)) {
      const other = deduped.get(e.name)!;
      console.warn(
        `[generate-components-typedefs] Duplicate component name "${e.name}"\n` +
          `  keeping: ${other.absPath}\n  ignoring: ${e.absPath}`
      );
      continue;
    }
    deduped.set(e.name, e);
  }

  const sorted = [...deduped.values()].sort((a, b) => a.name.localeCompare(b.name));

  const header = `// generated by scripts/generate-component-typedefs.ts
// It's suggested you commit this file into source control
`;

  const body =
    'declare global {\n' +
    sorted
      .map((e) => `    const ${e.name}: typeof import("${e.importPath}")["default"]`)
      .join('\n') +
    '\n}\n\nexport {}\n';

  const content = header + body;

  await writeIfChanged(OUTPUT_PATH, content);

  console.info(
    `[generate-components-typedefs] Wrote ${sorted.length} component${sorted.length === 1 ? '' : 's'} to ${path.relative(
      process.cwd(),
      OUTPUT_PATH
    )}`
  );
}

async function collectSvelteFiles(dir: string): Promise<string[]> {
  const out: string[] = [];
  await walk(dir, out);
  // Filter *.svelte (ignore hidden files/dirs by default)
  return (
    out
      .filter((p) => p.toLowerCase().endsWith('.svelte'))
      // Optional: ignore story/test files if you use them
      .filter((p) => !/[.-](test|spec|stories)\.svelte$/i.test(p))
  );
}

async function walk(dir: string, out: string[]) {
  const entries = await fs.readdir(dir, { withFileTypes: true });
  for (const entry of entries) {
    if (entry.name.startsWith('.')) continue; // skip hidden
    const full = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      await walk(full, out);
    } else if (entry.isFile()) {
      out.push(full);
    }
  }
}

function toPascalCase(input: string): string {
  // Handle common separators and camelCase already
  // Examples:
  //   "ability-bar" -> "AbilityBar"
  //   "AbilityBar" -> "AbilityBar"
  //   "ability_bar" -> "AbilityBar"
  //   "ability.bar" -> "AbilityBar"
  //   "ability bar" -> "AbilityBar"
  const parts = input
    .replace(/([a-z0-9])([A-Z])/g, '$1 $2')
    .split(/[\s._-]+/g)
    .filter(Boolean);

  return parts.map((s) => s.charAt(0).toUpperCase() + s.slice(1)).join('');
}

async function dirExists(dir: string): Promise<boolean> {
  try {
    const st = await fs.stat(dir);
    return st.isDirectory();
  } catch {
    return false;
  }
}

async function writeIfChanged(filePath: string, next: string) {
  try {
    const prev = await fs.readFile(filePath, 'utf8');
    if (prev === next) return; // no change
  } catch {
    // file doesn't existâ€”proceed to write
  }
  await fs.mkdir(path.dirname(filePath), { recursive: true });
  await fs.writeFile(filePath, next, 'utf8');
}

export function componentsTypedefsPlugin() {
  const globs = ['src/components/**/*.svelte'];
  const debounce = (fn: () => void, ms: number) => {
    let t: any;
    return () => {
      clearTimeout(t);
      t = setTimeout(fn, ms);
    };
  };
  const run = debounce(() => {
    generateComponentsTypedefs().catch((e) => console.error('[typedefs] generation failed:', e));
  }, 120);

  return {
    name: 'components-typedefs',
    apply: 'serve',
    configureServer(server: any) {
      // initial run
      run();
      // watch for add/change/remove of svelte components
      server.watcher.add(globs);
      server.watcher.on('add', run);
      server.watcher.on('change', run);
      server.watcher.on('unlink', run);
    },
    // Optional: also generate before prod builds
    async buildStart() {
      await generateComponentsTypedefs();
    }
  };
}

// Keep the CLI entry for manual runs:
if (import.meta.main) {
  generateComponentsTypedefs().catch((err) => {
    console.error('[generate-components-typedefs] Error:', err);
    process.exit(1);
  });
}
